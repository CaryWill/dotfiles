#+TITLE: √Ålvaro Ram√≠rez
#+AUTHOR: √Ålvaro Ram√≠rez
#+OPTIONS: toc:nil num:nil ^:nil
* [2023-12-22 Fri] A Murder at the End of the World: Are you Vi or Emacs?
:PROPERTIES:
:CUSTOM_ID: are-you-vi-or-emacs
:END:

I've enjoyed watching [[https://www.imdb.com/title/tt15227418/][A Murder at the End of the World]]. The show may resonate with folks following the tech world. Won't say much more than that...

What I can maybe say is, the shows features [[https://www.reddit.com/r/emacs/][Reddit]], [[https://brave.com/][Brave browser]], terminal usage (ifconfig, nmap, hydra, responder), and a reference to the good 'ol [[https://en.wikipedia.org/wiki/Editor_war][Vi vs Emacs rivalry]], which I hope folks these days don't take further than friendly teasing between dear cousins.

In any case, being an Emacs nut, the scene gave me a good tickle. It's a great show, with a lovely Emacs cherry on top! While the show title and description didn't immediately draw me in, I'm glad I gave it a chance.

#+ATTR_HTML: :width 100%
[[file:images/are-you-vi-or-emacs/vi-or-emacs.webp]]

#+ATTR_HTML: :width 100%
[[file:images/are-you-vi-or-emacs/what-is-emacs.webp]]

* [2023-12-17 Sun] An basic Mullvad WireGuard setup for macOS
:PROPERTIES:
:CUSTOM_ID: a-quick-mullvad-macos-setup
:END:
Needed a VPN to test an API from a different location. Gave [[https://mullvad.net/en][Mullvad]] a try.

Pretty neat, you can generate an account number without providing an email address. You can also pre-pay with a ton of options, including cash, crypto, credit cards, PayPal, wire transfers...

After seeing your account credited, one can download a [[https://mullvad.net/en/account/wireguard-config][generated WireGuard configuration]]. Also a WireGuard noob, so took this opportunity to give it a try.

The [[https://apps.apple.com/us/app/wireguard/id1451685025?mt=12][WireGuard macOS app]] has an "Import Tunnel(s) from File..." option where you can import the .conf file downloaded from [[https://mullvad.net/en/account/wireguard-config][Mullvad's generated config]]. After that, all I had to do was click the "Activate" button and [[https://en.wikipedia.org/wiki/Bob%27s_your_uncle][Bob's your uncle]].

#+ATTR_HTML: :width 95%
[[file:images/a-quick-mullvad-macos-setup/wg-redact.png]]

You can test your connection via:

#+begin_src bash
  curl https://am.i.mullvad.net/connected
#+end_src

#+RESULTS:
: You are connected to Mullvad (server xxxxxx). Your IP address is xxx.xxx.xxx.xxx

I had a brief stint at using the command-line alternative via homebrew =brew install wireguard-go wireguard-tools=, but that seems to fail silently:

#+begin_src sh
  wg-quick up xxxxx
  [#] wireguard-go utun
  [+] Interface for xxxxx is utun7
  [#] wg setconf utun7 /dev/fd/63
  [#] ifconfig utun7 inet xxx.xxx.xxx.xxx/xx xxx.xxx.xxx.xxx alias
  [#] ifconfig utun7 inet6 xxxx:xxxx:xxxx:xxxx::x:xxxx/xxx alias
  [#] ifconfig utun7 up
  [#] route -q -n add -inet6 ::/1 -interface utun7
  [#] route -q -n add -inet6 8000::/1 -interface utun7
  [#] route -q -n add -inet xxx.xxx.xxx.xxx/x -interface utun7
  [#] route -q -n add -inet xxx.xxx.xxx.xxx/x -interface utun7
  [#] route -q -n add -inet xxx.xxx.xxx.xxx -gateway xxx.xxx.xxx.xxx
  [#] networksetup -getdnsservers Wi-Fi
  [#] networksetup -getsearchdomains Wi-Fi
  [#] networksetup -getdnsservers iPhone USB
  [#] networksetup -getsearchdomains iPhone USB
  [#] networksetup -getdnsservers Thunderbolt Bridge
  [#] networksetup -getsearchdomains Thunderbolt Bridge
  [#] networksetup -getdnsservers xxxxx
  [#] networksetup -getsearchdomains xxxxx
  [#] networksetup -setdnsservers iPhone USB xxx.xxx.xxx.xxx
  [#] networksetup -setsearchdomains iPhone USB Empty
  [#] networksetup -setdnsservers xxxxx xxx.xxx.xxx.xxx
  [#] networksetup -setsearchdomains xxxxx Empty
  [#] networksetup -setdnsservers Wi-Fi xxx.xxx.xxx.xxx
  [#] networksetup -setsearchdomains Wi-Fi Empty
  [#] networksetup -setdnsservers Thunderbolt Bridge xxx.xxx.xxx.xxx
  [#] networksetup -setsearchdomains Thunderbolt Bridge Empty
  [+] Backgrounding route monitor
#+end_src

#+begin_src bash
  curl https://am.i.mullvad.net/connected
#+end_src

#+RESULTS:
: You are not connected to Mullvad. Your IP address is xxx.xxx.xxx.xxx

I'm on a Macbook M1 Pro, running macOS Sonoma. If you got =wg-quick= working on Sonoma, I'd love to hear from ya ([[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]]).


* [2023-12-06 Wed] An iOS journaling app powered by org plain text
:PROPERTIES:
:CUSTOM_ID: an-ios-journaling-app-powered-by-org-plain-text
:END:
I've been experimenting with building a rich text editing component for iOS, powered by [[https://orgmode.org/][org]] markup. The idea is to offer a mobile-friendly editing experience, backed by our beloved plain text format.

#+ATTR_HTML: :width 60%
[[file:images/an-ios-journaling-app-powered-by-org-plain-text/rich-text-experiment.gif]]

To make things a little more interesting, I'm introducing a new org-based app to help anyone with regular journaling.

#+BEGIN_EXPORT html
<p style="text-align: center;">
üëâ Meet ‚ú®Journelly‚ú®
</p>
#+END_EXPORT

#+ATTR_HTML: :width 60%
[[file:images/an-ios-journaling-app-powered-by-org-plain-text/journelly.jpg]]

Plain text /is/ the serialization format. No conversion/import/export needed.

#+ATTR_HTML: :width 60%
[[file:images/an-ios-journaling-app-powered-by-org-plain-text/journelly.gif]]

Though it's early days, it's fairly functional. Been using it daily for some time. You can opt in to use an external org file and sync with your beloved Emacs.

Want to give it a try? Want a TestFlight invite? Send me an email address (any would do) at either of these: [[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]].

The topic of org being fairly Emacs-oriented, though a strength for someone far down the rabbit hole, it is [[https://indieweb.social/@ringtailringo@mastodon.social/111533733278287863][understandable to call it out for someone in a different position]]. Lucky for us, org markup is plain text and can be implemented by apps other than Emacs, like Journelly itself for iOS and even more experimentally on macOS:

#+ATTR_HTML: :width 100%
[[file:images/an-ios-journaling-app-powered-by-org-plain-text/macos.png]]


And like Journelly for iOS, I got other org things available on iOS:

#+BEGIN_EXPORT html
<p style="text-align: center;">
      <a href='https://plainorg.com'>
        <img style='padding-top: 5px; width: 4ch;' src='https://plainorg.com/favicon.ico'/>
      </a>
      <a href='https://apps.apple.com/app/id1671420139'>
        <img style='padding-top: 5px; width: 4ch;' src='https://raw.githubusercontent.com/xenodium/xenodium.github.io/master/images/scratch-a-minimal-scratch-area/scratch_icon.png'/>
      </a>
      <a href='https://flathabits.com'>
        <img style='padding-top: 5px; width: 4ch;' src='https://flathabits.com/favicon.ico'/>
      </a>
</p>
#+END_EXPORT

- As an [[https://orgmode.org/][Org mode]] fan, so I wrote [[https://plainorg.com/][Plain Org]] for iOS. It's on the [[https://apps.apple.com/app/id1578965002][App Store]].
- Inspired by [[https://jamesclear.com/atomic-habits][Atomic Habits]], I wrote [[https://flathabits.com/][Flat Habits]] for iOS. Also on the [[https://apps.apple.com/app/id1558358855][App Store]].
- I needed an Emacs-inspired [[https://xenodium.com/scratch-a-minimal-scratch-area][*scratch*]] buffer on iOS (who doesn't?), so I [[https://xenodium.com/scratch-a-minimal-scratch-area/][built one]].

Just like the stuff I do or [[https://xenodium.com][write about]]? [[https://github.com/sponsors/xenodium][Sponsor me]].

* [2023-11-29 Wed] Building your own bookmark launcher
:PROPERTIES:
:CUSTOM_ID: building-your-own-bookmark-launcher
:END:
#+ATTR_HTML: :style text-align:right;
/‚ú®[[https://github.com/sponsors/xenodium][sponsor]]‚ú® this content/

I've been toying with the idea of managing browser bookmarks from [[https://www.gnu.org/software/emacs/][you know where]]. Maybe dump a bunch of links into an org file and use that as a quick and dirty bookmark manager. We'll start with a flat list plus fuzzy searching and see how far that gets us.

The org file would look a little something like this:

#+CAPTION: bookmarks.org
#+begin_src org
  My bookmarks
  - [[https://lobste.rs/t/emacs][Emacs editor (Lobsters)]]
  - [[https://emacs.stackexchange.com][Emacs Stack Exchange]]
  - [[https://www.reddit.com/r/emacs][Emacs subreddit]]
  - [[https://emacs.ch][Emacs.ch (Mastodon)]]
  - [[https://www.emacswiki.org][EmacsWiki]]
  - [[https://planet.emacslife.com/][Planet Emacslife]]
#+end_src

Next we need fuzzy searching, but first let's write a little elisp to extract all links from the org file:

#+begin_src emacs-lisp :lexical no
  (require 'org-element)
  (require 'seq)

  (defun browser-bookmarks (org-file)
    "Return all links from ORG-FILE."
    (with-temp-buffer
      (let (links)
        (insert-file-contents org-file)
        (org-mode)
        (org-element-map (org-element-parse-buffer) 'link
          (lambda (link)
            (let* ((raw-link (org-element-property :raw-link link))
                   (content (org-element-contents link))
                   (title (substring-no-properties (or (seq-first content) raw-link))))
              (push (concat title
                            "\n"
                            (propertize raw-link 'face 'whitespace-space)
                            "\n")
                    links)))
          nil nil 'link)
        (seq-sort 'string-greaterp links))))
#+end_src

The snippet uses =org-element= to iterate over links to collect/return them in a list. We join both the title and url, so searching can match either of these values. We also add a little formatting (new lines/face) to spiff things up.

#+begin_src emacs-lisp :results value code
  (browser-bookmarks "/private/tmp/bookmarks.org")
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
(#("Planet Emacslife\nhttps://planet.emacslife.com/\n" 17 46
   (face whitespace-space))
 #("EmacsWiki\nhttps://www.emacswiki.org\n" 10 35
   (face whitespace-space))
 #("Emacs.ch (Mastodon)\nhttps://emacs.ch\n" 20 36
   (face whitespace-space))
 #("Emacs (Stack Exchange)\nhttps://emacs.stackexchange.com\n" 23 54
   (face whitespace-space))
 #("Emacs (Reddit)\nhttps://www.reddit.com/r/emacs\n" 15 45
   (face whitespace-space))
 #("Emacs (Lobsters)\nhttps://lobste.rs/t/emacs\n" 17 42
   (face whitespace-space)))
#+end_src

We can now feed our list to our preferred narrowing framework (ivy, helm, ido, vertico) and use it to quickly select a bookmark. In the past, I've [[https://xenodium.com/emacs-utilities-for-your-os/][used the likes of ivy-read]] directly, though have since adopted the humble but mighty =completing-read= which hooks up to any of the above frameworks.

With that in mind, let's use =completing-read= to make a selection and split the text to extract the corresponding URL. Feed it to =browse-url=, and you got your preferred browser opening your bookmark.

#+begin_src emacs-lisp :lexical no
  (defun open-bookmark ()
    (interactive)
    (browse-url (seq-elt (split-string (completing-read "Open: " (browser-bookmarks "/private/tmp/bookmarks.org")) "\n") 1)))
#+end_src

I remain a happy ivy user, so we can see its fuzzy searching in action.

#+ATTR_HTML: :width 100%
[[file:images/building-your-own-bookmark-launcher/emacs-bookmark.gif]]

At this point, we now have our bookmark-launching Emacs utility. It's only an =M-x open-bookmark= command away, but we want to make it accessible from anywhere in our operating system, in my case macOS.

Let's enable launching from the command line, though before we do that, let's craft a dedicated frame for this purpose.

#+begin_src emacs-lisp :lexical no
  (defmacro present (&rest body)
    "Create a buffer with BUFFER-NAME and eval BODY in a basic frame."
    (declare (indent 1) (debug t))
    `(let* ((buffer (get-buffer-create (generate-new-buffer-name "*present*")))
            (frame (make-frame '((auto-raise . t)
                                 (font . "Menlo 15")
                                 (top . 200)
                                 (height . 20)
                                 (width . 110)
                                 (internal-border-width . 20)
                                 (left . 0.33)
                                 (left-fringe . 0)
                                 (line-spacing . 3)
                                 (menu-bar-lines . 0)
                                 (minibuffer . only)
                                 (right-fringe . 0)
                                 (tool-bar-lines . 0)
                                 (undecorated . t)
                                 (unsplittable . t)
                                 (vertical-scroll-bars . nil)))))
       (set-face-attribute 'ivy-current-match frame
                           :background "#2a2a2a"
                           :foreground 'unspecified)
       (select-frame frame)
       (select-frame-set-input-focus frame)
       (with-current-buffer buffer
         (condition-case nil
             (unwind-protect
                 ,@body
               (delete-frame frame)
               (kill-buffer buffer))
           (quit (delete-frame frame)
                 (kill-buffer buffer))))))
#+end_src

Most of the snippet styles our new frame and invokes the body parameter. While I don't typically resort to macros, we get a little syntatic sugar here, so we can invoke like so:

#+begin_src emacs-lisp :lexical no
  (defun present-open-bookmark-frame ()
    (present (browse-url (seq-elt (split-string (completing-read "Open: " (browser-bookmarks "/private/tmp/bookmarks.org")) "\n") 1))))
#+end_src

Wrapping our one-liner with the =present-open-bookmark-frame= function enables us to easily invoke from the command line, with something like

#+begin_src sh
  emacsclient -ne "(present-open-bookmark-frame)"
#+end_src

#+ATTR_HTML: :width 100%
[[file:images/building-your-own-bookmark-launcher/command.gif]]

Now that we can easily invoke from the command line, we have the flexibility to summon from anywhere. We can even bind to a key shortcut, available anywhere (not just Emacs). I typically do this via [[http://www.hammerspoon.org/][Hammerspoon]], with some helpers, though there are likely simpler options out there.

#+begin_src lua
  function emacsExecute(activate, elisp)
     if activate then
        activateFirstOf({
              {
                 bundleID="org.gnu.Emacs",
                 name="Emacs"
              }
        })
     end

     local socket, found = emacsSocketPath()
     if not found then
        hs.alert.show("Could not get emacs socket path")
        return "", false
     end

     local output,success = hs.execute("/opt/homebrew/bin/emacsclient -ne \""..elisp.."\" -s "..socket)
     if not success then
        hs.alert.show("Emacs did not execute: "..elisp)
        return "", false
     end

     return output, success
  end

  function openBookmark()
     appRequestingEmacs = hs.application.frontmostApplication()
     emacsExecute(false, "(present-open-bookmark-frame)")
     activateFirstOf({
           {
              bundleID="org.gnu.Emacs",
              name="Emacs"
           }
     })
  end

  hs.hotkey.bind({"alt"}, "W", openBookmark)
#+end_src

With that, we have our Emacs-powered bookmark launcher, available from anywhere.

#+ATTR_HTML: :width 100%
[[file:images/building-your-own-bookmark-launcher/launcher.gif]]

While we used our Emacs frame presenter to summon our universal bookmark launcher, we can likely the same mechanism for other purposes. Maybe a clipboard (kill ring) manager?

#+ATTR_HTML: :width 100%
[[file:images/building-your-own-bookmark-launcher/kill-ring.png]]

What would you use it for? Get in touch ([[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]]).

/Enjoying this content? Find it useful? Consider ‚ú®[[https://github.com/sponsors/xenodium][sponsoring]]‚ú®./
* [2023-11-25 Sat] Native Emacs/macOS UX integrations via Swift modules
:PROPERTIES:
:CUSTOM_ID: native-emacsmacos-ux-integrations-via-swift-modules
:END:
Once you learn a little [[https://en.wikipedia.org/wiki/Emacs_Lisp][elisp]], [[https://www.gnu.org/software/emacs/][Emacs]] becomes this hyper malleable editor/platform. A live playground of sorts, where almost everything is up for grabs at runtime. Throw some elisp at it, and you can customize or extend almost anything to your heart's content. I say almost, as there's a comparatively small native core, that would typically require recompiling if you wanted to make further (native) mods. But that isn't entirely true. [[https://www.masteringemacs.org/article/whats-new-in-emacs-25-1][Emacs 25]] enabled us to further extend things by loading native [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Dynamic-Modules.html][dynamic modules]], back in 2016.

Most of my Emacs-bending adventures have been powered by elisp, primarily on macOS. I also happen to have an iOS dev background, so when [[https://github.com/SavchenkoValeriy][Valeriy Savchenko]] [[https://www.reddit.com/r/emacs/comments/wemj1z/writing_emacs_dynamic_modules_in_swift/][announced]] his project bringing [[https://github.com/SavchenkoValeriy/emacs-swift-module][Emacs dynamic modules powered by Swift]], I added it to my never-ending list of things to try out.

Fast-forward to a year later, and [[https://github.com/roife][Roife]]'s [[https://www.reddit.com/r/emacs/comments/17vrmrk/emt_emacs_macos_tokenizer_for_enhanced_cjk_word/][introduction]] to [[https://github.com/roife/emt][emt]] finally gave me that much-needed nudge to give [[https://github.com/SavchenkoValeriy/emacs-swift-module][emacs-swift-module]] a try. While I wish I had done it earlier, I also wish [[https://github.com/SavchenkoValeriy/emacs-swift-module][emacs-swift-module]] had gotten more visibility. Native extensions written in Swift can open up some some neat integrations using native macOS UX/APIs.

While I'm new to Savchenko's [[https://github.com/SavchenkoValeriy/emacs-swift-module][emacs-swift-module]], the project has [[https://savchenkovaleriy.github.io/emacs-swift-module/documentation/emacsswiftmodule/][wonderful documentation]]. It quickly got me on my way to build an experimental dynamic module introducing a native context menu for sharing files from my beloved editor.

#+ATTR_HTML: :width 90%
[[file:images/native-emacsmacos-ux-integrations-via-swift-modules/emacs-share.webp]]

Most of the elisp/native bridging magic happens with fairly little Swift code:

#+begin_src swift
  try env.defun(
    "macos-module--share",
    with: """
      Share files in ARG1.

      ARG1 must be a vector (not a list) of file paths.
      """
  ) { (env: Environment, files: [String]) in
    let urls = files.map { URL(fileURLWithPath: $0) }

    let picker = NSSharingServicePicker(items: urls)
    guard let view = NSApp.mainWindow?.contentView else {
      return
    }

    let x = try env.funcall("macos--emacs-point-x") as Int
    let y = try env.funcall("macos--emacs-point-y") as Int

    let rect = NSRect(
      x: x + 15, y: Int(view.bounds.height) - y + 15, width: 1, height: 1
    )
    picker.show(relativeTo: rect, of: view, preferredEdge: .maxY)
  }
#+end_src

This produced an elisp =macos-module--share= function I could easily access from elisp like so:

#+begin_src emacs-lisp :lexical no
  (defun macos-share ()
    "Share file(s) with other macOS apps.

  If visiting a buffer with associated file, share it.

  While in `dired', any selected files, share those.  If region is
  active, share files in region.  Otherwise share file at point."
    (interactive)
    (macos-module--share (vconcat (macos--files-dwim))))
#+end_src

On a side note, =(macos--files-dwim)= chooses files depending on context. That is, [[https://xenodium.com/emacs-dwim-do-what-i-mean/][do what I mean (DWIM) style]]. If there's a file associated with current buffer, share it. When in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] (the directory editor, aka file manager), look at region, selected files, or default to file at point.

#+begin_src emacs-lisp :lexical no
  (defun macos--files-dwim ()
    "Return buffer file (if available) or marked/region files for a `dired' buffer."
    (if (buffer-file-name)
        (list (buffer-file-name))
      (or
       (macos--dired-paths-in-region)
       (dired-get-marked-files))))

  (defun macos--dired-paths-in-region ()
    "If `dired' buffer, return region files.  nil otherwise."
    (when (and (equal major-mode 'dired-mode)
               (use-region-p))
      (let ((start (region-beginning))
            (end (region-end))
            (paths))
        (save-excursion
          (save-restriction
            (goto-char start)
            (while (< (point) end)
              ;; Skip non-file lines.
              (while (and (< (point) end) (dired-between-files))
                (forward-line 1))
              (when (dired-get-filename nil t)
                (setq paths (append paths (list (dired-get-filename nil t)))))
              (forward-line 1))))
        paths)))
#+end_src

I got one more example of a native macOS integration I added. Being an even simpler one, and in hindsight, I prolly should have introduced it first. In any case, this one reveals [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] files in macOS's Finder app (including the selection itself).

#+ATTR_HTML: :width 100%
[[file:images/native-emacsmacos-ux-integrations-via-swift-modules/reveal.webp]]

#+begin_src swift
  try env.defun(
    "macos-module--reveal-in-finder",
    with: """
      Reveal (and select) files in ARG1 in macOS Finder.

      ARG1 mus be a vector (not a list) of file paths.
      """
  ) { (env: Environment, files: [String]) in
    NSWorkspace.shared.activateFileViewerSelecting(files.map { URL(fileURLWithPath: $0) })
  }
#+end_src

The corresponding elisp is nearly identical to its =macos-share= sibling:

#+begin_src emacs-lisp :lexical no
  (defun macos-reveal-in-finder ()
    "Reveal file(s) in macOS Finder.

  If visiting a buffer with associated file, reveal it.

  While in `dired', any selected files, reveal those.  If region is
  active, reveal files in region.  Otherwise reveal file at point."
    (interactive)
    (macos-module--reveal-in-finder (vconcat (macos--files-dwim))))
#+end_src

My Swift module experiment introduces two native macOS UX integrations, now available via =M-x macos-share= and =M-x macos-reveal-in-finder=. I've pushed all code to it's own [[https://github.com/xenodium/EmacsMacOSModule][repo]].

I hope this post brings visibility to the wonderful [[https://github.com/SavchenkoValeriy/emacs-swift-module][emacs-swift-module]] project and sparks new, native, and innovative integrations for those on macOS. Can't wait to see what others can do with it.

/Enjoying this content? Find it useful? Consider ‚ú®[[https://github.com/sponsors/xenodium][sponsoring]]‚ú®./

* [2023-11-16 Thu] Migrating/re-encrypting pass's password store
:PROPERTIES:
:CUSTOM_ID: migratingre-encrypting-passs-password-store
:END:
Note to self, I needed to migrate/re-encrypt someone's password store (aka pass). Straightforward:

Get the new key, probably already in gpg key chain. Try listing it:

#+begin_src sh
  gpg --list-keys
#+end_src

To re-encrypt, =pass init= with new key is enough. It'll prompt for old pass key.

#+begin_src sh
  cd path/to/.password-store
  pass init NEW-GPG-KEY
#+end_src
* [2023-10-30 Mon] How I smash burgers
:PROPERTIES:
:CUSTOM_ID: how-i-smash-burgers
:END:
I'm neither a burger expert nor a connoisseur of any kind, yet I sure have a lot of fun smashing burgers at home. Needless to say, I shamelessly enjoy gobbling them too!

#+CAPTION: my smash burger
#+ATTR_HTML: :width 60%
[[file:images/how-i-smash-burgers/burger-cut.png]]

I'll share details on how I smash my burgers, but here's a quick ingredient list, if that's all you need.

- Mince beef (20%-30% fat).
- Streaky bacon.
- Brioche burger buns.
- American cheese slices (cheddar individual slices work too).
- Lettuce.
- Tomatoes.
- Onions.
- Pickles.
- Jalape√±os.
- Garlic.
- Chipotle powder.
- Mayonnaise.
- Salt.
- Pepper.
- Oil.
- Greaseproof paper.
- Butter.

** The calling

My quest to smash burgers at home didn't start until earlier this year, while watching the [[https://www.imdb.com/title/tt9764362/][The Menu]]. I just could't stop [[https://indieweb.social/@xenodium/109734285674122246][craving the burger]] from that scene, so I set out to start smashing my own.

#+ATTR_HTML: :width 98%
[[file:images/how-i-smash-burgers/the-menu.webp]]

** The gear

Don't rush to buy anything fancy. Your existing gear will likely do the job just fine. I'd say try a few things out and only upgrade when needed. I'll share the gear I use and where I felt I needed tweaking.

** Skillet

While I didn't have a griddle at home, I did have a couple of trusty [[https://www.lodgecastiron.com/][Lodge]] *skillets* ([[https://www.lodgecastiron.com/product/round-cast-iron-classic-skillet?sku=L8SK3][cast iron]] and [[https://www.lodgecastiron.com/product/carbon-steel-skillet?sku=CRS12][carbon steel]]). Both work great for burgers, though I have a slight preference for the carbon steel one, as it's the bigger of the two and gives a little more room for manoeuvring, specially when smashing two burgers at a time.

#+ATTR_HTML: :width 250px
[[file:images/how-i-smash-burgers/cast-iron.png]]

#+ATTR_HTML: :width 250px
[[file:images/how-i-smash-burgers/carbon.png]]

Heat the skillet up and add a little oil. If the oil starts smoking, be quick to drop the patties and start smashing.

** Grill Spatula (too big/stiff for skillet)

Somewhat inspired by the film, I got myself a wide spatula so I could firmly press those patties against the skillet, and to flip of course.

While this kind of spatula may work well on a spacious griddle, I felt constrained on a relatively small cast iron. Specially when flipping. I went looking for an alternative.

#+ATTR_HTML: :width 250px
[[file:images/how-i-smash-burgers/spatula.png]]

** Spatula + smasher (my winning combo)

Over at the [[https://reddit.com/r/castiron/][r/castiron]] subreddit, I discovered fish spatulas. They are fairly agile on cast irons but also work great for loosening burger patties before flipping.

[[file:images/how-i-smash-burgers/ready.webp]]

While effective for flipping, fish spatulas are obviously no good for smashing. So I got myself a burger smasher. This combo worked well for me.

[[file:images/how-i-smash-burgers/smash.webp]]

When smashing, use greaseproof paper to prevent the patties from sticking to the smasher.

** Ingredients

While I've drawn inspiration from others, I've landed on my own preferred ingredients. I'm sure that will continue changing over time. Pick and choose as your heart desires.

** Minced/ground beef

Minced beef with higher fat content (around 20-30%) is often recommended for a couple of reasons:

- Flavour: Fat equals flavour in cooking. The higher fat content will melt during cooking and become 'self-basting', resulting in a juicier and more flavourful burger.

- Texture: The fat in the beef melts under heat, helping the burger achieve a crispy, caramelized exterior known as the [[https://en.wikipedia.org/wiki/Maillard_reaction][Maillard reaction]], which contrasts nicely against the soft, juicy interior.

In the UK, I can typically find minced beef with 15%-20% fat content at the main supermarkets.

#+ATTR_HTML: :width 200px
[[file:images/how-i-smash-burgers/pattie.png]]

Be sure to salt and pepper to taste (as in picture) on one side. Once flipped on pan, salt and pepper the other side.

** Bacon

I tend to prefer smoked streaky bacon, but hey these will be your burgers. Your burgers, your rules.

#+ATTR_HTML: :width 250px
[[file:images/how-i-smash-burgers/streaky.png]]

** Buns (brioche)

I hear potato buns are great for burgers. I've yet to try them. So far, I've settled for brioche. I happen to find these near me, so I've gone with them.

#+ATTR_HTML: :width 350px
[[file:images/how-i-smash-burgers/brioche.png]]

Butter the buns and brown on the skillet for a minute. Check the buns often. Brioche buns can burn quickly.

** American cheese

American cheese is often the burger cheese of choice.

#+ATTR_HTML: :width 98%
[[file:images/how-i-smash-burgers/american-cheese.webp]]

While American cheese isn't widely available in the UK, the individually wrapped orange-looking cheddar cheese slices work just fine.

#+ATTR_HTML: :width 250px
[[file:images/how-i-smash-burgers/cheese.png]]

** Toppings

I like my burgers with lettuce, tomatoes, onions, pickles, and occasionally jalape√±os. For pickles, I typically just take cornichons and slice them up.

#+ATTR_HTML: :width 350px
[[file:images/how-i-smash-burgers/toppings_x0.30.png]]

** Burger sauce (chipotle/garlic/mayo)

While classic burger sauce is often made with mayo, ketchup, pickles, and mustard, I've gone fairly rogue here.

You see, I love chipotle mayo. I'm also a fan of garlic mayo, so I figured why not both? Turns out these three ingredients work great together.

I like to draw out the flavours by first mixing the garlic and chipotle with a little hot water.

- 1 garlic clove.
- 2 teaspoons of chipotle powder.
- 1 tablespoon of hot water.
- Pinch of salt.

#+ATTR_HTML: :width 210px
[[file:images/how-i-smash-burgers/sauce1.png]]

#+ATTR_HTML: :width 210px
[[file:images/how-i-smash-burgers/sauce2.png]]

#+ATTR_HTML: :width 210px
[[file:images/how-i-smash-burgers/sauce3.png]]

...and then thicken with mayo.

- 1/4 cup of mayo.

#+ATTR_HTML: :width 210px
[[file:images/how-i-smash-burgers/sauce4.png]]

#+ATTR_HTML: :width 210px
[[file:images/how-i-smash-burgers/sauce5.png]]

These are very rough measurements, tweak to your preference. Make more garlicky, spicier, or soften things by adding garlic, chipotle, or mayo.

** Assembling

I like to assemble in the following order from the bottom bun up.

1. Sauce on bottom bun.
2. Lettuce.
3. Tomatoes.
4. Onions.
5. 2 patties (melted cheese on both).
6. Bacon.
7. Pickles.
8. Jalape√±os.
9. Sauce on top bun (oops, I forgot in the picture).

#+ATTR_HTML: :width 60%
[[file:images/how-i-smash-burgers/open.png]]

...and here's the final product.

#+ATTR_HTML: :width 60%
[[file:images/how-i-smash-burgers/burger-cut.png]]

If you gave smashing burgers a go, I'd love to hear about it. Also any tips are very much welcome. Get in touch ([[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]]).

* [2023-10-24 Tue] Open in Xcode at line number
:PROPERTIES:
:CUSTOM_ID: open-in-xcode-at-line-number
:END:
I live mostly in Emacs. I say mostly 'cause well, I'm fairly pragmatic about it. If there's a workflow elsewhere that's more appropriate for my needs, I'll happily use that instead. While I'd love to do my web browsing from my beloved editor, Firefox ticks the right boxes for me.

I do most of my iOS coding in Emacs. It's a hybrid of sorts between Emacs and Xcode. If I need to use the debugger, Xcode is a clear winner for me. If I happen to be visiting a Swift file in an Emacs buffer, I typically used the handy =crux-open-with= from [[https://github.com/bbatsov/crux][crux]] to open in Xcode, and continue from there. This worked OK, but I always wished opening in Xcode would also jump to the same line number as the Emacs point (cursor) location. This is particularly useful if I had just spotted where I'd like to set a breakpoint in an Emacs buffer and need to transition over to Xcode.

It turns out, there's a nifty command line utility for that. [[https://www.unix.com/man-page/osx/1/xed/][xed]], the Xcode text editor invocation tool. It enables telling Xcode what file to open and at what line number:

#+begin_src sh
  xed -line 141 path/to/some/file.swift
#+end_src

With that in mind, I've added my own version of =crux-open-with=, using [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]].

When running on macOS, the function checks whether or not I'm visiting a buffer for a programming language, and opens the file in Xcode at the same line number.

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-open-externally ()
    "Open file(s) externally."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Open externally"
     (if (eq system-type 'darwin)
         (if (derived-mode-p 'prog-mode)
             (format "xed --line %d '<<f>>'"
                     (line-number-at-pos (point)))
           "open '<<f>>'")
       "xdg-open '<<f>>'")
     :shell-args '("-x" "-c")
     :silent-success t
     :utils (if (eq system-type 'darwin)
                "open"
              "xdg-open")))
#+end_src

#+ATTR_HTML: :width 80%
[[file:images/open-in-xcode-at-line-number/xed_x0.8_x2.webp]]

=dwim-shell-commands-open-externally= is now [[https://github.com/xenodium/dwim-shell-command/commit/19be1c2f3792c95f04fd369cb931a52f7df9cfd5][added to dwim-shell-commands.el]].

ps. If you find opening the same file in a different context handy, you may also like the package [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] that opens the visited file at its corresponding remote location (for example, GitHub). I can never remember the name of the function ([[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]]), so I aliased it to something I'd remember and moved on...

#+begin_src emacs-lisp :lexical no
  (defalias 'ar/open-at-github #'browse-at-remote))
#+end_src

* [2023-10-06 Fri] Trimming video screenshots
:PROPERTIES:
:CUSTOM_ID: trimming-video-screenshots
:END:
A quick one... I recently wanted to trim the black borders around a video screenshot. While I could use an image editor to manually select and trim, I wondered if there was an [[https://imagemagick.org/][imagemagick]] trick somewhere out there for such a thing... and of course there was:

#+begin_src sh
  magick convert -fuzz 3% -define trim:percent-background=0% -trim +repage path/to/input.png path/to/output.png
#+end_src

Pretty neat. It does the job, but I won't remember it next time. May as well make another [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] function out of it and conveniently invoke from Emacs via a memorable name plus fuzzy search.

#+ATTR_HTML: :width 80%
[[file:images/trimming-video-screenshots/trim.gif]]

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-image-trim-borders ()
    "Trim image(s) border (useful for video screenshots)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Trim image border"
     "magick convert -fuzz 3% -define trim:percent-background=0% -trim +repage '<<f>>' '<<fne>>_trimmed.<<e>>'"
     :utils "magick"))
#+end_src

While the screenshot I've just used was a little blurry, it's from the movie [[https://www.imdb.com/title/tt1104001/][Tron Legacy]], and it features Emacs eshell. This is old news, though [[https://irreal.org/blog/?p=9573][well covered]].

#+ATTR_HTML: :width 95%
[[file:images/trimming-video-screenshots/eshell_trimmed.png]]

=dwim-shell-commands-image-trim-borders= is now [[https://github.com/xenodium/dwim-shell-command/commit/5bed2f6b40761db4913c8d8f58bb147c71a9ceb7][added to dwim-shell-commands.el]]

* [2023-10-06 Fri] Displaying image details in mode line
:PROPERTIES:
:CUSTOM_ID: displaying-image-details-in-mode-line
:END:
A benefit of running Emacs as a GUI app, is that you can view images from your beloved editor. This is super handy to take a quick peek at any image.

Sometimes, I'd like a little more than just viewing the image. I'd like to see basic image details like type, dimensions, and file size. The [[https://imagemagick.org/][imagemagick]] =identify= utility is pretty handy for that.

#+begin_src bash
  identify -format "%m %wx%h %b" path/to/image.png
#+end_src

#+RESULTS:
: PNG 2387x1055 2.28454MB

I could easily invoke =shell-command= for this or even create a [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] function (maybe I will), but if this info was proactively displayed in the mode line, I wouldn't have to fetch it myself.

Since I know I can use the =identify= command for this, I may as well see if I can plug it into the mode line.

Turns out this wasn't too bad by setting =setting mode-line-format=. I added a little logic to only include image details while in =image-mode= and rely on =process-lines= to fetch the details. This function returns a list, which is a happy coincidence since =mode-line-format= also expects a list.

#+begin_src emacs-lisp :lexical no
  (setq-default mode-line-format
                '(" "
                  mode-line-front-space
                  mode-line-client
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  (:eval
                   (when (eq major-mode 'image-mode)
                     ;; Needs imagemagick installed.
                     (process-lines "identify" "-format" "[%m %wx%h %b]" (buffer-file-name))))
                  " "
                  mode-line-position
                  (vc-mode vc-mode)
                  (multiple-cursors-mode mc/mode-line)
                  " " mode-line-modes
                  mode-line-end-spaces))
#+end_src

#+ATTR_HTML: :width 70%
[[file:images/displaying-image-details-in-mode-line/buddies.png]]

I'd love to hear if there's a pure elisp alternative ([[https://indieweb.social/@xenodium][mastodon]]/[[https://twitter.com/xenodium][twitter]]). I gave =(image-size (image-get-display-property) :pixels)= a try, but that seemed to return the display size in buffer rather than actual file size.

* [2023-10-06 Fri] Creating an iCloud account (via tart VM)
:PROPERTIES:
:CUSTOM_ID: creating-icloud-test-accounts
:END:
I wanted an additional @icloud.com account for myself. My first thought was to head over to https://developer.apple.com and create a new account, but that requires an existing email address. I wanted an actual @icloud.com email address.

#+ATTR_HTML: :width 80%
[[file:images/creating-icloud-test-accounts/web.png]]

My next thought was to create a new account using the iOS simulator, but that complained about creating too many accounts already. Strange, as I hadn't created any.

#+ATTR_HTML: :width 60%
[[file:images/creating-icloud-test-accounts/iphone.png]]

I could create an account from macOS settings itself, though that would require logging out my current account (and the syncing implications). To get around that, I could maybe create a temporary macOS user. Instead, I somewhat revisited the simulator route and looked for a VM option to run macOS. This gave me an excuse to play with VM options on macOS.

I had been meaning to check out [[https://github.com/lima-vm/lima][lima]] as per Hacker News's [[https://news.ycombinator.com/item?id=36668964][Lima: A nice way to run Linux VMs on Mac]]. The Hacker News's [[https://news.ycombinator.com/item?id=36668964][thread]] has a handful of great recommendations. Amongst them, [[https://github.com/cirruslabs/tart/][tart]] (macOS and Linux VMs on Apple Silicon) stood out, as it also gave me the Mac on Mac option.

Installing =tart= via [[https://brew.sh/][Homebrew]] followed the typical =brew= command... a breeze via my trusty Emacs [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][eshell]]:

#+begin_src sh
  brew install cirruslabs/cli/tart
#+end_src

Cloning a VM image, while straightforward, it did take a little while for the chunky download:

#+begin_src sh
  tart clone ghcr.io/cirruslabs/macos-sonoma-base:latest sonoma-base
#+end_src

Running the macOS Sonoma VM was a breeze:

#+begin_src sh
  tart run sonoma-base
#+end_src

...and with that, I got a full (and disposable) macOS VM I can use to create another @icloud.com account:

#+ATTR_HTML: :width 95%
[[file:images/creating-icloud-test-accounts/sonoma1.png]]

#+ATTR_HTML: :width 95%
[[file:images/creating-icloud-test-accounts/sonoma2.png]]

While there may be simpler options out there to create an @icloud.com account (please do let me know [[https://indieweb.social/@xenodium][mastodon]]/[[https://twitter.com/xenodium][twitter]]), the VM did the job. I'd been meaning to find a low friction mechanism to run VMs for a different reason, but that's a post for another time.

* [2023-10-04 Wed] Virtual machine (VM) bookmarks
:PROPERTIES:
:CUSTOM_ID: virtual-machine-vm-bookmarks
:END:
:MODIFIED:
[2023-10-04 Wed]
:END:
- [[https://github.com/abiosoft/colima][colima: Container runtimes on macOS (and Linux) with minima...]].
- [[https://github.com/runfinch/finch][finch: The Finch CLI an open source client for container development]].
- [[https://earthly.dev/blog/lima/][lima VM - Linux Virtual Machines On macOS - Earthly Blog]].
- [[https://news.ycombinator.com/item?id=36668964][lima: A nice way to run Linux VMs on Mac | Hacker News]].
- [[https://github.com/lima-vm/lima][lima: Linux virtual machines]].
- [[https://github.com/beringresearch/macpine][macpine: Lightweight Linux VMs on MacOS]].
- [[https://orbstack.dev/][OrbStack ¬∑ Fast, light, simple Docker & Linux on macOS]].
- [[https://github.com/cirruslabs/tart/][tart: macOS and Linux VMs on Apple Silicon to use in CI a...]].
- [[https://eclecticlight.co/virtualisation-on-apple-silicon/][Virtualisation on Apple silicon ‚Äì The Eclectic Light Company]].
* [2023-09-16 Sat] Emacs hangs saving .authinfo.gpg (workaround)
:PROPERTIES:
:CUSTOM_ID: emacs-hangs-saving-authinfogpg-workaround
:END:
My Emacs (v29.1) was hanging when saving changes to .authinfo.gpg. Turns out, I ran into a [[http://git.savannah.gnu.org/cgit/emacs.git/commit/etc/PROBLEMS?id=1b9812af80b6ceec8418636dbf84c0fbcd3ab694][known issue]] with a workaround. Downgrading gnupgp to a version older than 2.4.1 sorts things out.

I'm on macOS. Downgraded by downloading the 2.4.0 Homebrew formula at https://raw.githubusercontent.com/Homebrew/homebrew-core/59edfe598541186430d49cc34f42671e849e2fc9/Formula/gnupg.rb and installing with:

#+begin_src sh
  brew unlink gnupg
  brew install ~/Downloads/gnupg.rb
#+end_src
* [2023-09-15 Fri] Redact that buffer
:PROPERTIES:
:CUSTOM_ID: redact-that-buffer
:END:
As I was getting ready to take an Emacs screenshot in the [[https://xenodium.com/emacs-send-to-kindle/][previous post]], I figured I may want to redact email addresses before moving forward. I had a quick look for existing options and found [[https://github.com/bkaestner/redacted.el][redacted.el]], built-in =toggle-rot13-mode=, and [[https://github.com/alphapapa/unpackaged.el#obfuscate-buffer-text-with-lorem-ipsum-words][unpackaged/lorem-ipsum-overlay]]. All great options. I wanted a solution I could feed a single regular expression to obscure matches. I also wanted toggling capabilities, so I had a quick go at it...


#+ATTR_HTML: :width 98%
[[file:images/redact-that-buffer/redact-regexp.gif]]


I also wanted the ability to redact the entire buffer content, so feeding a space to the regexp query also translates to =[[:graph:]]=, effectively redacting all visible characters.

#+ATTR_HTML: :width 98%
[[file:images/redact-that-buffer/redact-all.gif]]

The solution is overlay-based, ensuring the buffer content remains unchanged. The function may have its own rough edges, yet it certainly scratched the itch for the current need. I'll leave ya with the snippet.

#+begin_src emacs-lisp :lexical no
  (defun ar/toggle-redact-buffer ()
    "Redact buffer content matching regexp. A space redacts all."
    (interactive)
    (let* ((redacted)
           (regexp (string-trim (read-regexp "Redact regexp" 'regexp-history-last)))
           (matches (let ((results '()))
                      (when (string-empty-p regexp)
                        (setq regexp "[[:graph:]]")
                        (setq regexp-history-last regexp)
                        (add-to-history 'regexp-history regexp))
                      (save-excursion
                        (goto-char (point-min))
                        (while (re-search-forward regexp nil t)
                          (push (cons (match-beginning 0) (match-end 0)) results)))
                      (nreverse results))))
      (mapc (lambda (match)
              (dolist (overlay (overlays-in (car match) (cdr match)))
                (setq redacted t)
                (delete-overlay overlay))
              (unless redacted
                (overlay-put (make-overlay (car match) (cdr match))
                             'display (make-string (- (cdr match) (car match)) ?x))))
            matches)))
#+end_src

* [2023-09-15 Fri] Send note to Kindle
:PROPERTIES:
:CUSTOM_ID: emacs-send-to-kindle
:END:
While on Mastodon, I spotted [[https://indieweb.social/@summeremacs@fashionsocial.host][@summeremacs]] looking into [[https://indieweb.social/@summeremacs@fashionsocial.host/111058226788825431][sending Emacs text selections to a Kindle via email]]. This sparked my interest as I previously looked into [[https://xenodium.com/emailing-pdfs-to-kindle-from-mu4e/][sending pdfs to my Kindle]] via [[https://github.com/djcb/mu][mu4e]].

Kindle offers a neat service where you can email a file to your =@kindle.com= address and it automatically shows up in your Kindle library.

I already do email from my beloved editor, and like most Emacs things, it's powered by [[https://en.wikipedia.org/wiki/Emacs_Lisp][elisp]]. In other words, it's basically up for grabs if you'd like to glue it to anything else, so I did...

I can now select a region and invoke =M-x send-to-kindle-as-txt= to send it over to my Kindle.

#+ATTR_HTML: :width 80%
[[file:images/emacs-send-to-kindle/send-to-my-kindle.gif]]

Soon enough, the note shows up on my Kindle.

#+ATTR_HTML: :width 70%
[[file:images/emacs-send-to-kindle/listed.png]]

Opening the note reveals the same content we had previously selected and sent from our malleable editor.

#+ATTR_HTML: :width 70%
[[file:images/emacs-send-to-kindle/repeated.png]]

While it looks kinda magical, it's fairly simple under the hood. It takes the region content, writes it to a txt file, creates an email message buffer attaching the file, and finally sends via =message-send-and-exit=.

If =M-x send-to-kindle-as-txt= is invoked with a =C-u= prefix, you get to inspect the message buffer right before sending via =C-c C-c=.

#+ATTR_HTML: :width 95%
[[file:images/emacs-send-to-kindle/email.png]]

Here's the full snippet.

#+begin_src emacs-lisp :lexical no
  (defcustom send-to-kindle-from-email
    nil
    "Your own email address to send from via mu4e."
    :type 'string
    :group 'send-to-kindle)

  (defcustom send-to-kindle-to-email
    nil
    "Your Kindle email address to send pdf to."
    :type 'string
    :group 'send-to-kindle)

  (defun send-to-kindle-as-txt (review)
    (interactive "P")
    (unless send-to-kindle-from-email
      (setq send-to-kindle-from-email
            (read-string "From email address: ")))
    (unless send-to-kindle-to-email
      (setq send-to-kindle-to-email
            (read-string "To email address: ")))
    (let* ((content (string-trim (if (region-active-p)
                                     (buffer-substring (region-beginning) (region-end))
                                   (buffer-string))))
           (note-name (let ((name (string-trim (read-string "Note name: "))))
                        (if (string-empty-p name)
                            (nth
                             0 (string-split
                                (substring content 0 (min 40 (length content))) "\n"))
                          name)))
           (path (concat (temporary-file-directory) note-name))
           (txt (concat path ".txt"))
           (buffer (get-buffer-create (generate-new-buffer-name "*Email txt*"))))
      (with-temp-buffer
        (insert content)
        (write-file txt))
      (with-current-buffer buffer
        (erase-buffer)
        ;; Disable hooks
        (let ((message-mode-hook nil))
          (message-mode))
        (insert
         (format
          "From: %s
  To: %s
  Subject: %s
  --text follows this line--
  <#multipart type=mixed>
  <#part type=\"text/plain\" filename=\"%s\" disposition=attachment>
  <#/part>
  <#/multipart>"
          send-to-kindle-from-email
          send-to-kindle-to-email
          note-name txt))
        (unless review
          (message-send-and-exit)))
      (when review
        (switch-to-buffer buffer))))
#+end_src

By the way, and I only just learned this today... To take a screenshot on a Kindle Paperwhite, tap on these opposite corners.

#+ATTR_HTML: :width 70%
[[file:images/emacs-send-to-kindle/tap-screenshot.png]]

* [2023-09-10 Sun] SHA-256 hash from URL, the easy way
:PROPERTIES:
:CUSTOM_ID: sha-256-hash-from-url-the-easy-way
:END:
From time to time, I need to generate a SHA-256 hash from a file hosted on some server. For me, this flow typically goes something along the lines of:

- Copy the file URL from browser.
- Drop to Emacs eshell.
- Change current directory.
- Type "curl -o file"
- Paste the file URL.
- Run curl command.
- Type "shasum -a 256 file".
- Run [[https://linux.die.net/man/1/shasum][shasum]] command.
- Copy the generated hash.
- Maybe delete the downloaded file?

We can maybe shave some steps off by downloading directly from the browser, though that may also bring additional clicks and navigating to a download location.

Amongst the steps, [[https://linux.die.net/man/1/shasum][shasum]] is the star player, and its output can be seen below.

#+begin_src bash
  shasum -a 256 path/to/downloaded/file
#+end_src

#+RESULTS:
: 3da351027e5b1495c7c7fe4abbf8d7ac9625da3604be5a35c9a9cbb92f6f955a  path/to/downloaded/file

Not a huge deal. One can copy the hash from the output, but why go through multiple small manual steps when I know I can get Emacs to simplify the lot? I've expedited a similar flow in the past when [[https://xenodium.com/emacs-clone-git-repo-from-clipboard/][cloning git repos]]. Let's simplify again so hashing a hosted file boils down to:

- Copy the file URL from browser.
- Run an Emacs interactive command.

This is where I pull out [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] (a little package I wrote) and glue the lot to get an expedited experience.

#+ATTR_HTML: :width 100%
[[file:images/sha-256-hash-from-url-the-easy-way/hash.gif]]

There isn't much to the function other than glueing a little elisp and a shell script via =dwim-shell-command= for some buffer/error handling.

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-sha-256-hash-file-at-clipboard-url ()
    "Download file at clipboard URL and generate SHA-256 hash."
    (interactive)
    (let ((url (current-kill 0)))
      (unless (string-match-p "^http[s]?://" url)
        (user-error "No URL in clipboard"))
      (dwim-shell-command-on-marked-files
       "Generate SHA-256 hash from clipboard URL."
       (format
        "temp_file=$(mktemp)
         function cleanup {
           rm -f $temp_file
         }
         trap cleanup EXIT
         curl --no-progress-meter --location --fail --output $temp_file %s || exit 1
         shasum -a 256 $temp_file | awk '{print $1}'"
        (shell-quote-argument url))
       :utils '("curl" "shasum")
       :on-completion
       (lambda (buffer process)
         (if-let ((success (= (process-exit-status process) 0))
                  (hash (with-current-buffer buffer
                          (string-trim (buffer-string)))))
             (progn
               (kill-buffer buffer)
               (kill-new hash)
               (message "Copied %s to clipboard"
                        (propertize hash 'face 'font-lock-string-face)))
           (switch-to-buffer buffer))))))
#+end_src

=dwim-shell-commands-sha-256-hash-file-at-clipboard-url= is now in [[https://github.com/xenodium/dwim-shell-command/blob/main/dwim-shell-commands.el][dwim-shell-commands.el]], the optional counterpart in [[https://github.com/xenodium/dwim-shell-command/][dwim-shell-command]].

** UPDATE

There's better way. Thanks to [[https://emacs.ch/@pkal][Philip Kaludercic]] for [[https://emacs.ch/@pkal/111041928308815477][suggesting]] =curl -s example.com | sha256sum - | cut -d " " -f1=
and [[https://emacs.ch/@sachac][Sacha Chua]] who pinged me about it.

Also note I'm now relying on the =<<cb>>= template, since dwim-shell-command replaces it with the clipboard/kill ring.

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-sha-256-hash-file-at-clipboard-url ()
    "Download file at clipboard URL and generate SHA-256 hash."
    (interactive)
    (unless (string-match-p "^http[s]?://" (current-kill 0))
      (user-error "No URL in clipboard"))
    (dwim-shell-command-on-marked-files
     "Generate SHA-256 hash from clipboard URL."
     "curl -s '<<cb>>' | sha256sum - | cut -d ' ' -f1"
     :utils '("curl" "sha256sum")
     :on-completion
     (lambda (buffer process)
       (if-let ((success (= (process-exit-status process) 0))
                (hash (with-current-buffer buffer
                        (string-trim (buffer-string)))))
           (progn
             (kill-buffer buffer)
             (kill-new hash)
             (message "Copied %s to clipboard"
                      (propertize hash 'face 'font-lock-string-face)))
         (switch-to-buffer buffer)))))
#+end_src

* [2023-09-05 Tue] Inline previous result and why you should edebug
:PROPERTIES:
:CUSTOM_ID: inline-previous-result-and-why-you-should-edebug
:END:
Artur Malabarba's [[https://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html][Debugging Elisp Part 1: Earn your independence]] is nearly a decade old, yet it rings just as true today.

Learning to Edebug really /"is the right decision for anyone who doesn't know how to Edebug."/ Why, you may ask? He best puts it as /"running into errors is not only a consequence of tinkering with your editor, it is the only road to graduating in Emacs."/

For me personally, it /earned me that independence/ to bend Emacs my way. Don't like how something works? Pull up the debugger to help me understand how a package or function works. I've done this countless of times to bend things my way.

Speaking of edebug, I had been meaning to tweak edebug's result display behaviour for quite some time. As you step through code, edbug prints the result of previous expressions to the minibuffer. This works well, but I couldn't help but feel like my eyes were constantly jumping between the code and the minibuffer at the bottom of the window.

#+ATTR_HTML: :width 70%
[[file:images/inline-previous-result-and-why-you-should-edebug/edebug-minibuffer.gif]]

I wanted to minimize the eye jumping experience, so I figured I could likely bend things my way and print the result at point. How did I go about it? The same way I often do. Figure out what function is called for a given key binding via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Key-Help.html][describe-key]] or my favourite replacement helpful-key from [[https://github.com/Wilfred/helpful][helpful.el]]. This led me to =edebug-next-mode= in =edebug.el=. At that point, I could have set a breakpoint in =edebug-next-mode= and eventually step into the relevant code, but hey we had a better clue. We knew that all output started with "Result:", so we could just search for that string in =edebug.el= instead. Jackpot! =edebug-compute-previous-result= and its adjacent =edebug-previous-result= are just the right functions:

#+begin_src emacs-lisp :lexical no
  (defun edebug-compute-previous-result (previous-value)
    (if edebug-unwrap-results
        (setq previous-value
              (edebug-unwrap* previous-value)))
    (setq edebug-previous-result
          (concat "Result: "
                  (edebug-safe-prin1-to-string previous-value)
                  (eval-expression-print-format previous-value))))

  (defun edebug-previous-result ()
    "Print the previous result."
    (interactive)
    (message "%s" edebug-previous-result))
#+end_src

We can see that =edebug-previous-result= invokes =message= which is responsible for displaying the debugged expression's result in the minibuffer. Modifying this functions behaviour would be enough to achieve inline display, but I also want to remove "Result:" from the displayed message. Neither of these functions offer configurability, so we'll resort to advising both functions. That is, [[https://en.wikipedia.org/wiki/Monkey_patch][monkey patch]] them (errm I know... lovely).

#+begin_src emacs-lisp :lexical no
  (defun adviced:edebug-compute-previous-result (_ &rest r)
    "Adviced `edebug-compute-previous-result'."
    (let ((previous-value (nth 0 r)))
      (if edebug-unwrap-results
          (setq previous-value
                (edebug-unwrap* previous-value)))
      (setq edebug-previous-result
            (edebug-safe-prin1-to-string previous-value))))

  (advice-add #'edebug-compute-previous-result
              :around
              #'adviced:edebug-compute-previous-result)
#+end_src

=adviced:edebug-compute-previous-result= removes "Result:" in addition to dropping =(eval-expression-print-format previous-value)=, which I don't typically rely on.

#+begin_src emacs-lisp :lexical no
  (require 'eros)

  (defun adviced:edebug-previous-result (_ &rest r)
    "Adviced `edebug-previous-result'."
    (eros--make-result-overlay edebug-previous-result
      :where (point)
      :duration eros-eval-result-duration))

  (advice-add #'edebug-previous-result
              :around
              #'adviced:edebug-previous-result)
#+end_src

=adviced:edebug-previous-result= is in charge of display via =message=, so all we need is some replacement. I initially played with [[https://github.com/auto-complete/popup-el][popup-tip]] and that [[https://indieweb.social/@xenodium/111008598580447299][did the job just fine]], but [[https://emacs.ch/@fosskers][Colin]] led me to a better path while [[https://emacs.ch/@fosskers/111009811997698187][pointing to Clojure and Common Lisp]]. This reminded me of [[https://github.com/xiongtx/eros][eros: Evaluation Result OverlayS for Emacs Lisp]], which I already used. Swapping =message= for =eros--make-result-overlay= did the trick. Yes, this is a private function, but I can live with that. This code is only an =advice-remove= away from disabling, but hey look at those /inline results/!

#+ATTR_HTML: :width 90%
[[file:images/inline-previous-result-and-why-you-should-edebug/edebug-inline.gif]]

* [2023-08-27 Sun] Further sqlite-mode extensions
:PROPERTIES:
:CUSTOM_ID: further-sqlite-mode-extensions
:END:
I've continued poking at Emacs 29's sqlite-mode. Since [[https://xenodium.com/sqlite-mode-goodies/][my last post on extensions]], I've experimented a little with adding a handful of interactive functions:

- =sqlite-mode-extras-compose-and-execute=: Compose and execute a query.
#+ATTR_HTML: :width 90%
[[file:images/further-sqlite-mode-extensions/compose-execute.gif]]
- =sqlite-mode-extras-execute=: Execute a query.
#+ATTR_HTML: :width 90%
[[file:images/further-sqlite-mode-extensions/execute.gif]]
- =sqlite-mode-extras-add-row=: Add row to table at point.
#+ATTR_HTML: :width 90%
[[file:images/further-sqlite-mode-extensions/add-row.gif]]
- =sqlite-mode-extras-delete-row-dwim=: Similar to =sqlite-mode-delete= but also enables deleting range in region.
#+ATTR_HTML: :width 90%
[[file:images/further-sqlite-mode-extensions/delete-rows.gif]]
- =sqlite-mode-extras-refresh=: Refreshes the buffer re-querying the database.
- =sqlite-mode-extras-ret-dwim=: If on table, toggle expansion. If on row, edit it.
- =sqlite-mode-extras-execute-and-display-select-query=: Executes a query and displays results.
#+ATTR_HTML: :width 90%
[[file:images/further-sqlite-mode-extensions/select-earth.gif]]

I've been playing with the following key bindings:

#+begin_src emacs-lisp :lexical no
  (use-package sqlite-mode-extras
    :bind (:map
           sqlite-mode-map
           ("n" . next-line)
           ("p" . previous-line)
           ("b" . sqlite-mode-extras-backtab-dwim)
           ("f" . sqlite-mode-extras-tab-dwim)
           ("+" . sqlite-mode-extras-add-row)
           ("D" . sqlite-mode-extras-delete-row-dwim)
           ("C" . sqlite-mode-extras-compose-and-execute)
           ("E" . sqlite-mode-extras-execute)
           ("S" . sqlite-mode-extras-execute-and-display-select-query)
           ("DEL" . sqlite-mode-extras-delete-row-dwim)
           ("g" . sqlite-mode-extras-refresh)
           ("<backtab>" . sqlite-mode-extras-backtab-dwim)
           ("<tab>" . sqlite-mode-extras-tab-dwim)
           ("RET" . sqlite-mode-extras-ret-dwim)))
#+end_src

The code lives in [[https://github.com/xenodium/dotsies/blob/main/emacs/ar/sqlite-mode-extras.el][sqlite-mode-extras.el]] under my [[https://github.com/xenodium/dotsies/tree/main][Emacs config repo]]. Beware, it's fairly experimental and hasn't been tested thoroughly.

* [2023-08-22 Tue] My custom Tesco Clubcard pkpass
:PROPERTIES:
:CUSTOM_ID: my-custom-tesco-clubcard-pkpass
:END:
My significant other and I had two plastic Tesco Clubcards. I lost mine, so I took a picture of hers. I was fairly certain a barcode photo would scan just as well at self-checkout, and it did.

This got me thinking about Apple's Wallet [[https://en.wikipedia.org/wiki/PKPASS][pkpasses]]. I don't really know much about them. Could I potentially create my own =.pkpass=? If I could just include the same barcode as in the photo, it should do the job just fine.

Now I should mention, [[https://apps.apple.com/gb/app/tesco-grocery-clubcard/id389581236][Tesco does have an app on the App Store]]. If you just want the official Wallet pass on your iPhone, use that. But I was curious about whether or not I could create my own pass.

Turns out I /can/. I followed Apple's [[https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/YourFirst.html][building your first pass]] which runs you through [[https://developer.apple.com/help/account/configure-app-capabilities/create-wallet-identifiers-and-certificates][creating Wallet identifiers/certificates]], editing =pass.json=, and downloading/building [[https://developer.apple.com/services-account/download?path=/iOS/Wallet_Support_Materials/WalletCompanionFiles.zip][signpass]] (the utility used to sign =.pass= bundles).

The =signpass= utility is included in WalletCompanionFiles.zip, which comes with a handful of sample passes.

#+begin_src emacs-lisp :lexical no
  WalletCompanionFiles
  ‚îÇ
  ‚îú‚îÄ‚îÄ SamplePasses
  ‚îÇ   ‚îÇ
  ‚îÇ   ‚îú‚îÄ‚îÄ BoardingPass.pass
  ‚îÇ   ‚îú‚îÄ‚îÄ Coupon.pass
  ‚îÇ   ‚îú‚îÄ‚îÄ Event.pass
  ‚îÇ   ‚îú‚îÄ‚îÄ Event.pkpass
  ‚îÇ   ‚îú‚îÄ‚îÄ Generic.pass
  ‚îÇ   ‚îî‚îÄ‚îÄ StoreCard.pass
  ‚îÇ       ‚îÇ
  ‚îÇ       ‚îú‚îÄ‚îÄ pass.json
  ‚îÇ       ‚îî‚îÄ‚îÄ ...
  ‚îî‚îÄ‚îÄ signpass
#+end_src

Being a rewards card, I opted to look into =StoreCard.pass=, but like all other passes, the =barcode= itself is what makes each pass scannable. The barcode details are specified in the bundles's =pass.json= file. I needed to figure out the relevant values describing the Tesco barcode.

#+begin_src json
  "barcode": {
    "format": "???",
    "message": "???",
    "messageEncoding": "???"
  }
#+end_src

I had no clue what values I should use for a Tesco Clubcard. I did, however, have a photo of the barcode I needed. This is in fact what prompted looking into [[https://xenodium.com/emacs-scan-this-qrcode][scanning barcodes from Emacs]], which worked just great. It gave me all the crucial bits for the Clubcard.

#+begin_src json
  "barcode": {
    "format": "PKBarcodeFormatCode128",
    "message": "1234567890123456",  // not my actual Clubcard number of course.
    "messageEncoding": "iso-8859-1"
  }
#+end_src

That's all that's needed for the barcode section, the most useful part of the pass. We're not done though. We also need our registered Wallet identifiers, so the =signpass= utility can sign.

#+begin_src json
  "passTypeIdentifier": "my.com.identifier.passmaker", // also not my actual one.
  "teamIdentifier": "AAABBBCCCD", // nor this one.
#+end_src

We should be able to sign the pass with the following:

#+begin_src sh
  signpass -p StoreCard.pass
#+end_src

We're technically done. We now have a working card, but it looks just like the sample store card included in WalletCompanionFiles.

#+ATTR_HTML: :width 50%
[[file:images/my-custom-tesco-clubcard-pkpass/lemons.png]]

What's the fun in that? Now that I can make my own Clubcard, let's customize it!

For imagery, I replaced a couple of images in the .pass bundle:

#+begin_src c
  StoreCard.pass
  ‚îÇ
  ‚îú‚îÄ‚îÄ pass.json
  ‚îú‚îÄ‚îÄ icon.png
  ‚îú‚îÄ‚îÄ logo.png // replaced
  ‚îî‚îÄ‚îÄ strip.png // replaced
#+end_src

I replaced =logo.png= using a [[https://en.wikipedia.org/wiki/File:Tesco_Logo.svg][Tesco logo I found on Wikipedia]]. I had initially removed =strip.png=, but that made the card feel a little empty. I was thinking of using a Tesco carrier bag to bulk the space up. While I didn't find a suitable bag image, I did land on "[[https://banksyexplained.com/very-little-helps-2008/][Very Little Helps, 2008]]". Using my limited [[https://www.gimp.org/][GIMP]] skills, I cropped one of the images and also replaced =strip.png=.

The remaining customizations took place in =pass.json= and should be fairly self-explanatory. There's the text shown in all labels as well as three customizable colours (background, label, and foreground).

#+begin_src json
  {
    "formatVersion": 1,
    "passTypeIdentifier": "my.com.identifier.passmaker", // also not my actual one.
    "teamIdentifier": "AAABBBCCCD", // nor this one.
    "serialNumber": "AnySerialNumberYouWant",
    "barcode": {
      "format": "PKBarcodeFormatCode128",
      "message": "1234567890123456",
      "messageEncoding": "iso-8859-1"
    },
    "organizationName": "Not Tesco of course",
    "description": "Not a Tesco reqards card",
    "logoText": "Clubcard",
    "foregroundColor": "rgb(255, 255, 255)",
    "labelColor": "rgb(255, 255, 255)",
    "backgroundColor": "rgb(2, 81, 158)", // Blue for that Tesco look
    "storeCard": {
      "auxiliaryFields": [
        {
          "key": "membership",
          "label": "Member since 2023",
          "value": ""
        },
        {
          "key": "membership2",
          "label": "Expires sometime",
          "value": ""
        }
      ]
    }
  }
#+end_src

...and with all that, here's what my very own custom Tesco Clubcard pkpass looks like. As you can appreciate, my image-editing skills aren't all that great, but hey this will do for now.

#+ATTR_HTML: :width 50%
[[file:images/my-custom-tesco-clubcard-pkpass/bsy.png]]

** Update

Redditor u/stupergenius [[https://www.reddit.com/r/programming/comments/15y4c65/comment/jxa1obg/?utm_source=share&utm_medium=web2x&context=3][suggested using the image's original background color]]. Nice suggestion. Tweaked via pass.json:

#+begin_src json
    "foregroundColor": "rgb(2, 81, 158)",
    "labelColor": "rgb(15, 58, 105)",
    "backgroundColor": "rgb(166, 202, 214)",
#+end_src

#+ATTR_HTML: :width 50%
[[file:images/my-custom-tesco-clubcard-pkpass/bsy-light.png]]
* [2023-08-07 Mon] Extending sqlite-mode (cell navigation + edits)
:PROPERTIES:
:CUSTOM_ID: sqlite-mode-goodies
:END:
I recently [[https://xenodium.com/emacs-29s-sqlite-mode/][wrote about Emacs 29's new sqlite-mode]], which enables you to browse sqlite databases from your beloved editor.

Out of the box, it supports the following browsing features:

- =sqlite-mode-list-data=: List the data from the table under point.
- =sqlite-mode-list-column=: List the columns of the table under point.
- =sqlite-mode-list-tables=: Re-list the tables from the currently selected database.

On the editing side of things it supports row deletion:

- =sqlite-mode-delete=: Delete the row under point.

While fairly spartan, it lays foundations for additional tools and features.

Two features I would like to have:

1. TAB navigation across table rows and columns.
2. Updating the row's field at point.

This would give me the familiar behaviour I'm used to in my org tables as well as other common spreadsheet tools.

Luckily, this is Emacs, so we can bend it our way... and I sure did!

Here's tab navigating forward:

#+ATTR_HTML: :width 75%
[[file:images/sqlite-mode-goodies/sqlite-forward.gif]]

Here's tab navigating backward:

#+ATTR_HTML: :width 75%
[[file:images/sqlite-mode-goodies/sqlite-previous.gif]]

And updating row fields:

#+ATTR_HTML: :width 90%
[[file:images/sqlite-mode-goodies/sqlite-edits.gif]]

Most of the navigation is achieved by querying the current buffer to figure out column positions. Editing was in some ways easier, as I looked at =sqlite-mode-delete= to figure out how it handled the query.

To get the more familiar navigation behaviour, I've adjusted my key bindings as follows:

#+begin_src emacs-lisp :lexical no
  (use-package sqlite-mode-extras
    :bind (:map
           sqlite-mode-map
           ("n" . next-line)
           ("p" . previous-line)
           ("<backtab>" . sqlite-mode-extras-backtab-dwim)
           ("<tab>" . sqlite-mode-extras-tab-dwim)
           ("RET" . sqlite-mode-extras-ret-dwim)))
#+end_src

The code for =sqlite-mode-extras-tab-dwim=, =sqlite-mode-extras-backtab-dwim=, and =sqlite-mode-extras-ret-dwim= is little rough still (hacky even), but hey still fun.

For now, the code lives in [[https://github.com/xenodium/dotsies/blob/main/emacs/ar/sqlite-mode-extras.el][sqlite-mode-extras.el]] under my [[https://github.com/xenodium/dotsies/tree/main][Emacs config repo]]. Improvements/fixes totally welcome!

* [2023-08-06 Sun] Emacs 29's sqlite-mode
:PROPERTIES:
:CUSTOM_ID: emacs-29s-sqlite-mode
:END:
I've jumped on the Emacs 29 bandwagon! Mickey Petersen has a great rundown of [[https://www.masteringemacs.org/article/whats-new-in-emacs-29-1][What's New in Emacs 29.1]].

Now every so often, I need to take a quick peek at an [[https://www.sqlite.org/index.html][sqlite3]] table. Emacs 29.1 ships [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Database.html][sqlite-mode]], which can help with that. Use =sqlite-mode-open-file= to open a database.

Pressing =RET= on a table shows its content via =sqlite-mode-list-data=. =DEL= does as you'd expect and delete a row via =sqlite-mode-delete=.

#+ATTR_HTML: :width 75%
[[file:images/emacs-29s-sqlite-mode/sqlite-mode.gif]]

* [2023-07-30 Sun] Emacs: scan this QR/bar code
:PROPERTIES:
:CUSTOM_ID: emacs-scan-this-qrcode
:END:
Another day, another tool brought to my Emacs fingertips. A while ago, I wrote about easily [[https://xenodium.com/copy-from-desktop-to-mobile-via-qr-code/][copying text from desktop to mobile via QR codes]]. Later on, I brought it under [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] as [[https://github.com/xenodium/dwim-shell-command/blob/67da65f97d7f5477e19407d25887c23fab31517d/dwim-shell-commands.el#L593][dwim-shell-commands-clipboard-to-qr]].

This time around, I needed the opposite: to scan a code from an image file. This is where [[https://github.com/mchehab/zbar][zbar]]'s =zbarimg= comes in. These days, I'm mostly on macOS, so I installed via [[https://brew.sh/][Homebrew]]:

#+begin_src sh
  $ brew install zbar
#+end_src

There's really nothing to the command. You feed it an image, and it outputs the scanned details. Perfect.

#+begin_src sh
  $ zbarimg path/to/code-128.png
  CODE-128:hello world
  scanned 1 barcode symbols from 1 images in 0.02 seconds
#+end_src

The only challenge is my brain. I probably won't remember the name of this wonderful tool next time I need it, so I'll just add it to my [[https://github.com/xenodium/dwim-shell-command/blob/main/dwim-shell-commands.el][dwim-shell-commands.el arsenal]] with a memorable name:

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-image-scan-code ()
    "Scan any code from image(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Scan code"
     "zbarimg '<<f>>'"
     :utils "zbarimg"))
#+end_src

In the future, rather than reaching out to =zbarimg= directly, I'll use my trusty fuzzy search and... voil√†!

#+ATTR_HTML: :width 85%
[[file:images/emacs-scan-this-qrcode/scan-dired.gif]]

Because =dwim-shell-command= operates on either =dired= files or current file, we can also apply our new function when viewing the QR code itself.

#+ATTR_HTML: :width 85%
[[file:images/emacs-scan-this-qrcode/scan-image.gif]]

=dwim-shell-commands-image-scan-code= is now [[https://github.com/xenodium/dwim-shell-command/commit/85ebcb0a466ddfe48e543d585e16aff7aee8da5e][pushed to dwim-shell-commands.el]], the optional package in [[https://github.com/xenodium/dwim-shell-command/][dwim-shell-command]].

* [2023-07-25 Tue] A cure for JavaScript fatigue?
:PROPERTIES:
:CUSTOM_ID: a-cure-for-javascript-fatigue
:END:
It's been roughly a decade since I wrote any significant amount of JavaScript. Back then, I primarily relied on the [[https://developers.google.com/closure/compiler/][Google Closure Compiler]], now maybe an archaeological artefact? These days, it's hard not to bump into any JavaScript project that doesn't rely on [[https://www.npmjs.com/][npm]], along with many other tools like the [[https://www.typescriptlang.org/][Typescript]] compiler, [[https://eslint.org/][ESLint]], [[https://prettier.io/][Prettier]]... There are a ton of available frameworks too. I was somewhat put off (or maybe just lazy?) by the initial ramp-up to reenter the JavaScript world. I guess that's what some refer to as [[https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.prcj59904][Javascript Fatigue]].

I'm giving JavaScript another try, but this time with an Emacs [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] standing by. Reentering the JavaScript world as a noob, I often know what I want to enable, but I'm unfamiliar with which project knobs to turn to set things up.

While I may want to dig deeper into things in the future, at present I just want to dabble with JavaScript. I want a local project set up as quickly as possible. ChatGPT has been pretty handy at that. The Emacs ChatGPT shell and its minibuffer prompts work fairly well for my needs, yet I often found myself wishing it could behave more like a [[https://magit.vc/][magit]] commit buffer. That is, launch a dedicated buffer (not the shell itself), ask the question, maybe paste some snippets, and send it on its way with that oh so familiar and satisfying =C-c C-c= binding ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Sending-Mail.html][sending mail]] also says hello).

This is where =M-x chatgpt-shell-prompt-compose= comes in. It's a mash between the ChatGPT shell and a magit commit buffer:

#+ATTR_HTML: :width 85%
[[file:images/a-cure-for-javascript-fatigue/node-chatgpt.gif]]

In the background, the buffer is still powered by the shell itself, so you can reuse it to ask clarifying questions.

#+ATTR_HTML: :width 85%
[[file:images/a-cure-for-javascript-fatigue/compose.gif]]

A couple of additional features worth mentioning... Invoking =chatgpt-shell-prompt-compose= with an active region automatically copies the region content over to the compose buffer. This is handy if you'd like to create more elaborate prompts with further editing. So far, this feels more natural than editing text from the shell or the minibuffer, where =RET= doesn't insert new lines.

The compose buffer is powered by a background shell (storing history for us). Typing =clear= followed by =C-c C-c= clears the background shell history.

=chatgpt-shell-prompt-compose= is available in [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] v0.72.1. I've so far bound it to =C-c C-e=, though I've already found some unfortunate clashes.

* [2023-07-12 Wed] ChatGPT visits the Emacs doctor
:PROPERTIES:
:CUSTOM_ID: chatgpt-visits-the-emacs-doctor
:END:
Emacs is a [[https://youtu.be/urcL86UpqZc?t=177][part-time job]]. A [[https://emacs-lsp.github.io/lsp-mode/][multi-language]] development environment. A [[https://www.emacswiki.org/emacs/LispMachine][lisp machine]]. An [[https://www.djcbsoftware.nl/code/mu/mu4e.html][email client]]. A [[https://www.gnu.org/software/emacs/manual/html_node/emacs/EWW.html][web browser]]. A [[https://youtu.be/AyhPmypHDEw][zettelkasten]]. A [[https://www.emacswiki.org/emacs/SpreadSheet][spreadsheet]]. A [[https://codeberg.org/martianh/mastodon.el][mastodon client]]. A [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][shell]]. A [[https://github.com/ledger/ledger-mode][ledger]]. A [[https://github.com/alphapapa/org-super-agenda][super agenda]]. An [[https://twitter.com/nixcraft/status/1435140596520218628][operating system]]. Some say it sends [[https://xkcd.com/378/][ripples into the atmosphere]] or [[https://github.com/skeeto/autotetris-mode][plays tetris for you]]. It may even [[https://github.com/johanvts/emacs-fireplace][warm your place up]] during the winter. Can [[https://github.com/TeMPOraL/nyan-mode][meme with you]]. It's an ultra-malleable editor with endless possibilities, powered by your life-long customizations. Oh man, no wonder we need to chat to someone from time to time. You know what I mean? /"[[https://knowyourmeme.com/editorials/guides/what-does-sir-this-is-a-wendys-mean][Sir, this is a Wendy's]]"/.

Luckily, we also have the built-in Emacs psychotherapist we can chat to, courtesy of [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Amusements.html][M-x doctor]]. It's powered by [[https://en.wikipedia.org/wiki/Emacs_Lisp][elisp]], and like all Emacs things, it's basically up for grabs. What I mean is, elisp implements many of these features, but also glues the lot for you. Once you learn a little elisp, you can build new Emacs features but also glue others for that magical compound effect.

#+ATTR_HTML: :width 85%
#+CAPTION: The Emacs doctor
[[file:images/chatgpt-visits-the-emacs-doctor/got-a-problem.gif]]

A little while ago, I wanted to give [[https://openai.com/blog/chatgpt][ChatGPT]] a try, preferably from Emacs (of course). I figured a shell interface would be a great fit for the interaction. Emacs already shipped with a general command interpreter ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Prompts.html][comint]]), so I cobbled together a [[https://xenodium.com/a-chatgpt-emacs-shell/][ChatGPT Emacs shell]].

#+ATTR_HTML: :width 75%
#+CAPTION: [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]]
[[file:images/chatgpt-visits-the-emacs-doctor/cyberpunk.gif]]

So where am I going with all this? The fine netizens [[https://www.reddit.com/user/emaphis/][r/emaphis]] and [[https://news.ycombinator.com/user?id=salgernon][salgernon]] both planted a great seed:

 - /"[[https://www.reddit.com/r/emacs/comments/11wdub9/comment/jczrlt7][Now for extra-credit, add the ability for Alt-X doctor to psychoanalyze Chat-GPT]]"/.
 - /"[[https://news.ycombinator.com/item?id=35259022][So how about a quick M-x psychoanalyze-chatgpt?]]"/

I haven't forgotten about you. Let's take [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]], /M-x doctor/, our versatile elisp glue, and let's make them talk:

#+CAPTION: courtesy of [[https://www.reddit.com/r/emacs/comments/122nm9r/comment/jdv9f1i][thriveth]] and [[https:/asset.dr.dk/imagescaler01/downol.dr.dk/download/bonanza/thumbs/000026814.jpg][dr.dk]].
[[file:images/chatgpt-visits-the-emacs-doctor/000026814.jpg]]

There isn't too much to the code, but beware:

1. If you want to run it, you'll need chatgpt-shell [[https://github.com/xenodium/chatgpt-shell#install][installed and set up]].
2. This was a quick fun hack. No code judging ;)


The snippet is further down... Start with =chatgpt-shell-visit-doctor= as the entry point, setting things up for us. It creates both the =*chatgpt*= and =*doctor*= buffers and arranges the windows next to each other.

We also set a ChatGPT system prompt to guide things a little:

#+begin_quote
  "Pretend to be an overwhelmed Emacs user who is obsessed with configuring their init.el file. You are in a session talking to a psychotherapist. Limit your output to no more than 20 words. In the course of 5 exchanges between you and the therapist, show improvements. On the 8th exchange after therapist speaks, declare you are cured and only output 'Thank you doc, I think I'm cured!'"
#+end_quote

ChatGPT and Emacs doctor can go on and on, so we limit ChatGPT responses to 20 words per response and 8 exchanges. We don't want the session to abruptly end without a resolution, so we'll use /Thank you doc, I think I'm cured!/ as our key phrase to end the session.

We register =chatgpt-shell--on-chatgpt-patient-response= as a hook to receive ChatGPT output, which we feed to the =*doctor*= buffer. We subsequently get a doctor response that's fed back to ChatGPT via =chatgpt-shell--insert-doc-response=.

We add some additional freebies like binding =Ctrl-c Ctrl-c= to =chatgpt-shell-leave-doctor=, so we can bail out of the exchange from the =*chatgpt*= buffer.

We also introduced =chatgpt-shell--insert-delayed-text= as a replacement for [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Insertion.html][insert]] to slow things down a little. For visual effects, really.

#+begin_src emacs-lisp :lexical no
  (require 'chatgpt-shell)

  (defun chatgpt-shell-visit-doctor ()
    (interactive)
    (setq chatgpt-shell--doctor-in-session t)
    (when (get-buffer "*doctor*")
      (kill-buffer "*doctor*"))
    (delete-other-windows)
    (split-window-horizontally)
    (other-window 1)
    (doctor)
    (visual-line-mode 1)
    (when (fboundp 'accent-menu-mode)
      (accent-menu-mode -1))
    (mapc
     (lambda (shell-buffer)
       (kill-buffer shell-buffer))
     (chatgpt-shell--shell-buffers))
    (other-window 1)
    (setq chatgpt-shell-system-prompts
          '(("Doc" . "Pretend to be an overwhelmed Emacs user who is obsessed with configuring their init.el file. You are in a session talking to a psychotherapist. Limit your output to no more than 20 words. In the course of 5 exchanges between you and the therapist, show improvements. On the 8th exchange after therapist speaks, declare you are cured and only output \"Thank you doc, I think I'm cured!\".")))
    (setq chatgpt-shell-system-prompts nil)
    (setq chatgpt-shell-system-prompt nil)
    (with-current-buffer (chatgpt-shell)
      (define-key chatgpt-shell-mode-map (kbd "C-c C-c")
        'chatgpt-shell-leave-doctor)
      (shell-maker-set-buffer-name (current-buffer)
                                   "*chatgpt*"))
    (chatgpt-shell--insert-doc-response))

  (defun chatgpt-shell--doc-conversation ()
    (let ((convo (with-current-buffer "*doctor*"
                   (split-string (buffer-string) "\n\n"))))
      (seq-remove
       (lambda (item)
         (string-empty-p (string-trim item)))
       (append
        ;; Replace first doc line, so it drops "Each time you are finished talking, type RET twice."
        (list "I am the psychotherapist.  Please, describe your problems.")
        (mapcar
         (lambda (item)
           (replace-regexp-in-string "\n" " " item))
         (cdr convo))))))

  (defun chatgpt-shell--doc-response ()
    (let* ((conversation (chatgpt-shell--doc-conversation))
           (length (seq-length conversation))
           (doc-response (nth (1- length) conversation)))
      doc-response))

  (defun chatgpt-shell--insert-doc-response ()
    (with-current-buffer "*chatgpt*"
      (goto-char (point-max))
      (chatgpt-shell--insert-delayed-text (chatgpt-shell--doc-response))
      (call-interactively 'shell-maker-submit)))

  (defun chatgpt-shell--insert-delayed-text (text)
    "Insert TEXT into the current buffer, with a delay between each character."
    (dolist (char (string-to-list text))
      (insert char)
      (sit-for 0.009)))

  (defun chatgpt-shell--on-chatgpt-patient-response (command output)
    (if (and chatgpt-shell--doctor-in-session
             (not (string-match-p (regexp-quote "I'm cured") output)))
        (progn
          (with-current-buffer "*chatgpt*"
            (goto-char (point-max)))
          (with-selected-window (get-buffer-window "*doctor*")
            (goto-char (point-max))
            (chatgpt-shell--insert-delayed-text output)
            (call-interactively 'doctor-ret-or-read)
            (chatgpt-shell--insert-doc-response)))
      (message "Bye Bye")))

  (defun chatgpt-shell-leave-doctor ()
    (interactive)
    (setq chatgpt-shell--doctor-in-session nil)
    (call-interactively 'chatgpt-shell-ctrl-c-ctrl-c))

  (add-hook 'chatgpt-shell-after-command-functions
            #'chatgpt-shell--on-chatgpt-patient-response)

  (global-set-key (kbd "M-q") #'chatgpt-shell-visit-doctor)
#+end_src

Ok, enough already. Let's see it in action.

#+ATTR_HTML: :width 100%
[[../images/chatgpt-visits-the-emacs-doctor/chatgpt-doc_optimized.gif][file:images/chatgpt-visits-the-emacs-doctor/chatgpt-doc_optimized.gif]]

If you'd like to take a closer look for analysis, here's the official transcript of this fruitful session:

#+begin_quote
I am the psychotherapist.  Please, describe your problems.  Each time you are finished talking, type RET twice.


I spend hours tweaking my Emacs config, but it's never perfect. I'm overwhelmed and obsessed with customization.


Is it because it's not ever perfect you are overwhelmed and obsessed with customization that you came to me?


Yes, I can't stop myself from constantly trying to tweak and improve my Emacs configuration. It's consuming me.


Emacs?  Hah!  I would appreciate it if you would continue.


Sorry about that. Yes, I came to you because I'm overwhelmed by my obsession with customizing my Emacs configuration.


Does it bother you that you are overwhelmed by your obsession with customizing your emacs configuration?


Absolutely! I feel trapped in an endless cycle of tweaking and configuring, unable to achieve satisfaction.


Why do you say that?


I constantly seek perfection in my Emacs config, but it's an unattainable goal that leaves me exhausted and frustrated.


When did you first know that it's an unattainable goal that leaves you exhausted and frustrated?


I've realized it recently after spending countless hours trying to perfect my Emacs configuration without any lasting satisfaction.


Are you sure?


Thanks you doc, I think I'm cured.
#+end_quote

While we can work exclusively with the =*doctor*= buffer making requests directly to the ChatGPT API, where's the fun in that? Getting the buffers to talk to each other enables us to marvel at both the beauty and absurdity of being able to glue anything together in our lovely Emacs world.

Happy Emacsing!

* [2023-07-09 Sun] chatgpt-shell v0.60.1 updates
:PROPERTIES:
:CUSTOM_ID: chatgpt-shell-v0601-updates
:END:

Back in April, I shared [[https://xenodium.com/chatgpt-shell-available-on-melpa/][chatgpt-shell updates]], showcasing [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] features. It's been a little while, so here's an update with the latest additions.

Like this project? Consider ‚ú®[[https://github.com/sponsors/xenodium][sponsoring]]‚ú®.

** Multi-session support
You can run multiple shell instances independently configured to use different versions or system prompts.

This was biggest recent change. Please report issues.

#+ATTR_HTML: :width 95%
[[file:images/chatgpt-shell-v0601-updates/cat-turtle.gif]]

** Display system prompt and version

The current shell's version and system prompt are now displayed more prominently in both the shell prompt and buffer name.

#+ATTR_HTML: :width 90%
[[file:images/chatgpt-shell-v0601-updates/display.png]]

With multi-session support, displaying shell details in the buffer name becomes more important as it makes it easier to find shells across your buffer list.

** Rename shell buffers

While buffer names are now automatically derived, one can also use =chatgpt-shell-rename-buffer= to use custom buffer names.

** ob-chatgpt-shell improvements

Use =:temperature= to specify the [[https://platform.openai.com/docs/api-reference/completions\
/create#completions/create-temperature][temperature]].

Use =:context CONTEXT-NAME= to pick and choose which source blocks to aggregate as context. Thank you [[https://github.com/jtmoulia][Thomas Moulia]].

Use =:preflight t= to debug =ob-chatgpt-shell= execution.

#+ATTR_HTML: :width 60%
[[file:images/chatgpt-shell-v0601-updates/preflight.png]]

** chatgpt-shell-write-git-commit

Adds =chatgpt-shell-write-git-commit=, so you can generate commit messages using the current region. Thank you [[https://github.com/bigsky77][Simon Judd]].

** Approximate context length

=chatgpt-shell= now uses =chatgpt-shell--approximate-context-length= to approximate the context size and discard history if necessary. This is pretty experimental but seems to work well enough. It's enabled by default to get some feedback. Please file bugs if needed or send PRs to improve.

**  =S-<return>= for multiline input

In addition to =C-J= to insert multi-line input, =S-<return>= is also supported. Thank you [[https://github.com/shouya][shouya]] for the submission.

** Welcome message

A welcome message now makes the help much more discoverable for new or sporadic users. Thank you [[https://github.com/shouya][shouya]] for the suggestion.

#+ATTR_HTML: :width 75%
[[file:images/chatgpt-shell-v0601-updates/welcome.png]]

** Help me

While the [[https://github.com/xenodium/chatgpt-shell][README]] documents the shells and Emacs is [[https://www.emacswiki.org/emacs/SelfDocumentation][self-documenting]], we now have a =help= command to make things a little more discoverable.

#+ATTR_HTML: :width 99%
[[file:images/chatgpt-shell-v0601-updates/help.png]]

** Hello chatgpt-shell-mode and dall-e-shell-mode

Both =chatgpt-shell= and =dall-e-shell= are both based on =shell-maker= and until recently both shared =shell-maker-mode= as their major mode. This didn't play well with yasnippet. Both shells now enable independent major modes: =chatgpt-shell-mode= and =dall-e-shell-mode=. Thank you [[https://github.com/djliden][Daniel Liden]] for the proposal.

** Saving transcript customizations

Make transcript saving more customizable via =shell-maker-transcript-default-path= and =shell-maker-transcript-default-filename=. Thank you [[https://github.com/gnusupport][gnusupport]].

** New ChatGPT model versions

New OpenAI model versions were recently released and added to chatgpt-shell: =gpt-3.5-turbo-0613= and =gpt-4-0613=. Thanks you [[https://github.com/suzuki][Norio Suzuki]].

** Load awesome prompts

=M-x chatgpt-shell-load-awesome-prompts= to download and import curated prompts from [[https://github.com/f/awesome-chatgpt-prompts][awesome-chatgpt-prompts]]. Thank you [[https://github.com/dangom][Daniel Gomez]].

#+ATTR_HTML: :width 75%
[[file:images/chatgpt-shell-v0601-updates/awesome.png]]

** ob-async

We had reports that ob-chatgpt-shell didn't play nice with [[https://github.com/astahlman/ob-async][ob-async]]. Thank you [[https://github.com/wmedrano][William Medrano]] for the solution.

** Configurable prompts

Functions like =chatgpt-shell-describe-code= ask ChatGPT to describe the code in region. These functions used hardcoded English prompts. These are now configurable, so users can tweak or translate if preferred. Thank you [[https://github.com/suzuki][Norio Suzuki]].

- =chatgpt-shell-prompt-header-describe-code=
- =chatgpt-shell-prompt-header-refactor-code=
- =chatgpt-shell-prompt-header-generate-unit-test=
- =chatgpt-shell-prompt-header-proofread-region=
- =chatgpt-shell-prompt-header-whats-wrong-with-last-command=
- =chatgpt-shell-prompt-header-eshell-summarize-last-command-output=
* [2023-07-05 Wed] Duplicate this!
:PROPERTIES:
:CUSTOM_ID: duplicate-this
:END:
[[http://www.dyerdwelling.family/][James Dyer]] has a nice [[https://www.emacs.dyerdwelling.family/emacs/20230606213531-emacs--dired-duplicate-here-revisited/][post]] sharing his frequent [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] need to duplicate files. He offers a solution using a custom interactive command. His use-case resonated with me.

Similarly, James' recommendation to bind his file-duplicating command to =C-c d= [1] sent a signal to my brain triggering [[https://twitter.com/bbatsov][Bozhidar Batsov]]'s =crux-duplicate-current-line-or-region=.

=crux-duplicate-current-line-or-region= is part of a "collection of Ridiculously useful extensions for Emacs" (yeah that's [[https://github.com/bbatsov/crux][crux]]). The command itself does what it says on the tin.

Let's duplicate the current line.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-line.gif]]

Now let's duplicate the current region.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-region.gif]]

Since I already have a well-internalized key-binding duplicating lines/regions in text buffers, I could extend a similar behaviour to dired files with almost zero adoption effort.

In case you haven't noticed, I've made it a [[https://youtu.be/urcL86UpqZc?t=177][part-time job]] to make command line utilities easily accessible from Emacs ([[https://xenodium.com/joining-images-from-the-comfort-of-dired/][1]] [[https://xenodium.com/emacs-dwim-shell-command/][2]] [[https://xenodium.com/emacs-password-protect-current-pdf-revisited/][3]] [[https://xenodium.com/dwim-shell-command-now-on-windows/][4]] [[https://xenodium.com/recordscreenshot-windows-the-lazy-way/][5]] [[https://xenodium.com/emacs-ffmpeg-and-macos-alias-commands/][6]] [[https://xenodium.com/emacs-quick-kill-process/][7]] [[https://xenodium.com/hey-emacs-change-the-default-macos-app-for/][8]] [[https://xenodium.com/hey-emacs-where-did-i-take-that-photo/][9]] [[https://xenodium.com/emacs-open-with-macos-app/][10]] [[https://xenodium.com/emacs-macos-sharing-dwim-style-improved/][11]] [[https://xenodium.com/emacs-macos-share-from-dired-dwim-style/][12]] [[https://xenodium.com/emacs-reveal-in-finder-dwim-style/][13]] [[https://xenodium.com/dwim-shell-command-usages-pdftotext-and-scp/][14]] [[https://xenodium.com/dwim-shell-command-with-template-prompts/][15]] [[https://xenodium.com/seamless-command-line-utils/][16]] [[https://xenodium.com/dwim-shell-command-video-streams/][17]] [[https://xenodium.com/dwim-shell-command-improvements/][18]] [[https://xenodium.com/dwim-shell-command-on-melpa/][19]] [[https://xenodium.com/emacs-dwim-shell-command-multi-language/][20]] [[https://xenodium.com/png-to-icns-emacs-dwim-style/][21]]) via [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]]. Partly because it's fairly quick and partly 'cause it's fun.

Jame's post gave me yet another opportunity to exercise my errrm part-time job. This time, duplicating files. All I need is the [[https://www.man7.org/linux/man-pages/man1/cp.1.html][cp]] utility and a template:

#+begin_src sh
  cp -R '<<f>>' '<<f(u)>>'
#+end_src

I seldom type these template's myself when I want to execute a command (via =M-x dwim-shell-command=). I typically wrap these templates in interactive commands, making them easily accessible via =M-x= and your favorite completion framework. I happen to use [[https://github.com/abo-abo/swiper][ivy]].

#+begin_src emacs-lisp :lexical no
  (require 'dwim-shell-command)

  (defun dwim-shell-commands-duplicate ()
    "Duplicate file(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Duplicate file(s)."
     "cp -R '<<f>>' '<<f(u)>>'"
     :utils "cp"))
#+end_src

There's nothing much to the command. Most logic is handled by the template, replacing =<<f>>= with the current file and =<<f(u)>>= with a uniquified version of it. Having said this, there's a bunch of free [[https://xenodium.com/emacs-dwim-do-what-i-mean/][DWIM]] love that kicks in, courtesy of the =dwim-shell-command= package by yours truly. Let's give our new =dwim-shell-commands-duplicate= command a spin.

Like =crux-duplicate-current-line-or-region= duplicates the current line, our new command duplicates the current dired file.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-file.gif]]

Got multiple files to duplicate? Like =crux-duplicate-current-line-or-region=, we can use the region for a similar purpose.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-files.gif]]

While we have been using the region to duplicate adjacent files, we can also mark specific files.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-marked.gif]]

Our =cp -R '<<f>>' '<<f(u)>>'= template uses the =-R= (recursive) flag, so we get another freebie. In addition to files, we can also duplicate directories.

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-dirs.gif]]

Lastly, because we're on a DWIM train, if your current buffer happens to be visiting a file, you can =M-x dwim-shell-commands-duplicate= the current file to duplicate it. You're automatically dropped to a dired buffer, with point on the new file (√† la [[https://emacsredux.com/blog/2013/09/24/dired-jump/][dired-jump]]).

#+ATTR_HTML: :width 95%
[[file:images/duplicate-this/duplicate-buffer.gif]]

While duplicating files using a template was a mere =cp -R '<<f>>' '<<f(u)>>'= away, we get a bunch of free DWIM magic applied to a handful of use-cases and contexts. What made the file-duplicating use-case extra special is that it maps almost exactly to an equivalent text command. Keep the same key bindings and we almost get a "[[https://endlessparentheses.com/hungry-delete-mode.html][free feature]]".

#+begin_src emacs-lisp :lexical no
  (use-package crux
    :ensure t
    :commands crux-open-with
    :bind
    (("C-c d" . crux-duplicate-current-line-or-region)))

  (use-package dwim-shell-command
    :ensure t
    :bind (:map dired-mode-map
                ("C-c d" . dwim-shell-commands-duplicate))
    :config
    ;; Loads all my own dwim shell commands
    ;; (including `dwim-shell-commands-duplicate')
    (require 'dwim-shell-commands))
#+end_src

You can find my ever-growing list of similar commands over at [[https://github.com/xenodium/dwim-shell-command/blob/main/dwim-shell-commands.el][dwim-shell-commands.el]] (the optional part of the package). Got some nifty usages? Would love to check 'em out. [[https://indieweb.social/@xenodium][Get in touch]].

Like this or [[https://xenodium.com/][other content]]? [[https://github.com/sponsors/xenodium][‚ú®Sponsor‚ú® via GitHub Sponsors]].

[1]: I actually use =C-x C-d= for =crux-duplicate-current-line-or-region= but same same...

** Update

If you're keen on a regex-based approach, [[https://www.reddit.com/user/arthurno1/][u/arthurno1]] [[https://www.reddit.com/r/emacs/comments/14rmvkx/comment/jqtkel8/?utm_source=share&utm_medium=web2x&context=3][offers a great built-in alternative]]: dired-do-copy-regexp (bound to =% C=).

* [2023-06-29 Thu] Stitching images from the comfort of dired
:PROPERTIES:
:CUSTOM_ID: joining-images-from-the-comfort-of-dired
:END:
I recently wanted a few images stitched together. A perfect job for [[https://imagemagick.org/][ImageMagick]]. A quick search yielded the magical incantation:

#+begin_src sh
  convert image1.jpg image2.jpg image3.jpg +append joined.jpg
#+end_src

Great, now I know, but I'll rarely use it and will soon forget it. I may as well add it to my [[https://github.com/xenodium/dwim-shell-command/blob/main/dwim-shell-commands.el][repository]] of [[https://en.wikipedia.org/wiki/DWIM][DWIM]] command line utilities, wrapped in a convenient Emacs function, applicable from different contexts... [[https://xenodium.com/emacs-dwim-do-what-i-mean/][know what I mean]]? üôÉ

I built [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] for this purpose. You can take the above command and easily turn it into an interactive Emacs command with something like the following:

#+begin_src emacs-lisp :lexical no
  (require 'dwim-shell-command)

  (defun dwim-shell-commands-join-images-horizontally ()
    "Join all marked images horizontally as a single image."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Join images horizontally"
     "convert -verbose '<<*>>' +append 'joined.jpg'"
     :utils "convert"))
#+end_src

You can select as many images as you'd like from the comfort of your dired and /make the ImageMagick happen/.

#+ATTR_HTML: :width 95%
[[file:images/joining-images-from-the-comfort-of-dired/burgers.gif]]

The snippet does the job just fine, but we can make it smarter. For starters, let's not hardcode the output filename. We'll ask the user instead. While we're asking, let's offer a default filename, but let's not assume the output extension is =.jpg=. Let's guess based on the image selection. While we're at it, let's not override the output file if already exists. Uniquify it.

Most of the above can be achieved by either using [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] helpers or its templating language. For example, =<<joined.png(u)>>= ensures that if =joined.png= already exists, it automatically generates =joined(1).png= instead.

#+begin_src emacs-lisp :lexical no
  (require 'dwim-shell-command)

  (defun dwim-shell-commands-join-images-horizontally ()
    "Join all marked images horizontally as a single image."
    (interactive)
    (let ((filename (format "joined.%s"
                            (or (seq-first (dwim-shell-command--file-extensions)) "png"))))
      (dwim-shell-command-on-marked-files
       "Join images horizontally"
       (format "convert -verbose '<<*>>' +append '<<%s(u)>>'"
               (dwim-shell-command-read-file-name
                (format "Join as image named (default \"%s\"): " filename)
                :default filename))
       :utils "convert")))
#+end_src

Here's the new horizontal command in action...

#+ATTR_HTML: :width 95%
[[file:images/joining-images-from-the-comfort-of-dired/burger_row_x1.5_optimized.gif]]

Notice how this time we didn't mark the images using =dired-mark=, typically bound to =m=. Instead, we made our selection using the region. Also, if you haven't gotten your junk food fix yet, here's the fries equivalent ;)

#+ATTR_HTML: :width 95%
[[file:images/joining-images-from-the-comfort-of-dired/fries_row_x1.5_optimized.gif]]

We'll rinse all and repeat to get the vertical command equivalent. I know, I know, there's fair amount of duplication but c'est la vie.

#+begin_src emacs-lisp :lexical no
  (require 'dwim-shell-command)

  (defun dwim-shell-commands-join-images-vertically ()
    "Join all marked images vertically as a single image."
    (interactive)
    (let ((filename (format "joined.%s"
                            (or (seq-first (dwim-shell-command--file-extensions)) "png"))))
      (dwim-shell-command-on-marked-files
       "Join images vertically"
       (format "convert -verbose '<<*>>' -append '<<%s(u)>>'"
               (dwim-shell-command-read-file-name
                (format "Join as image named (default \"%s\"): " filename)
                :default filename))
       :utils "convert")))
#+end_src

...and for our grand finale, we'll vertically join our burgers and fries. Behold!

#+ATTR_HTML: :width 95%
[[file:images/joining-images-from-the-comfort-of-dired/finale_x1.5_optimized.gif]]

These commands are now part of [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]]. To get them, load the optional commands via =(require 'dwim-shell-commands)=.

* [2023-06-18 Sun] noweb: the lesser known org babel glue
:PROPERTIES:
:CUSTOM_ID: noweb-more-glue-for-your-org-toolbox
:END:
While [[https://orgmode.org/][Org]] babel's [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]] isn't something I've frequently used for literate programming, its simplicity makes it rather versatile to glue all sorts of babel things I hadn't previously considered.

The idea is simple. Add a placeholder like =<<other-block>>= to an [[https://orgmode.org/manual/Working-with-Source-Code.html][org babel]] source block, and it will be automatically replaced (verbatim) with the content (or result) of referred block before execution. You'll also need the =:noweb yes= header argument.

#+begin_src org
  ,#+NAME: other-block
  ,#+begin_src swift
    print("Hello 0")
  ,#+end_src

  ,#+RESULTS: other-block
  : Hello 0

  ,#+BEGIN_SRC swift :noweb yes
    <<other-block>>
    print("Hello 1")
  ,#+END_SRC

  ,#+RESULTS:
  : Hello 0
  : Hello 1
#+end_src

Since =<<other-block>>= is replaced with the content of said block, at execution time, the block is effectively equivalent to executing:

#+BEGIN_SRC swift
  print("Hello 0")
  print("Hello 1")
#+END_SRC

#+RESULTS:
: Hello 0
: Hello 1

Why is this so versatile? Org babel can include/execute all sorts of languages, so you can mix and match the result from one language and massage it to appear as the body of another block using the same (or different) language.

I was recently asked [[https://github.com/xenodium/chatgpt-shell/issues/102][how to include the result from one babel block in another]] using [[https://github.com/xenodium/chatgpt-shell/#chatgpt-org-babel][ob-chatgpt-shell]]. While the initial question was looking for a solution involving variables, we can use noweb to achieve a similar goal.

Note that in this case, I'll be using =<<hello()>>=, with =()=, to refer to =#+RESULTS:= rather than the source block itself.

#+begin_src org
  ,#+NAME: hello
  ,#+BEGIN_SRC chatgpt-shell
  Say hello in spanish
  ,#+END_SRC

  ,#+RESULTS: hello
  Hola

  ,#+BEGIN_SRC chatgpt-shell :noweb yes
  <<hello()>>
  What does the previous line say verbatim?
  ,#+END_SRC
#+end_src

Executing the block

#+BEGIN_SRC chatgpt-shell :noweb yes
<<hello()>>
What does the previous line say verbatim?
#+END_SRC

Gives us

#+RESULTS:
: The previous line says "Hola".

On a similar note, I was asked if the results from a previous source block could be [[https://indieweb.social/@kickingvegas@sfba.social/110562099134297469][fed to a Swift Chart block]] using [[https://github.com/xenodium/ob-swiftui][ob-swiftui]].

While I'm new to [[https://developer.apple.com/documentation/Charts][Swift Charts]], I do love glueing things via Emacs lisp. I figured I could write a little elisp to generate random data and feed it to a SwiftUI block via =<<data()>>=. The result is pretty neat, based on Apple's [[https://developer.apple.com/documentation/charts/linemark][LineMark example]].

#+ATTR_HTML: :width 95%
[[file:images/noweb-more-glue-for-your-org-toolbox/data-chart.gif]]

#+begin_src org
  ,#+NAME: data
  ,#+begin_src emacs-lisp :lexical no
    (concat (mapconcat (lambda (n)
                         (format "MonthlyHoursOfSunshine(city: \"Seattle\", month: %d, hoursOfSunshine: %d),"
                                 n (random 100)))
                       (number-sequence 1 20) "\n")
            "\n"
            (mapconcat (lambda (n)
                         (format "MonthlyHoursOfSunshine(city: \"Cupertino\", month: %d, hoursOfSunshine: %d),"
                                 n (random 100)))
                       (number-sequence 1 20) "\n"))
  ,#+end_src

  ,#+begin_src swiftui :results file :noweb yes
    import Charts

    struct MonthlyHoursOfSunshine: Identifiable {
      var city: String
      var date: Date
      var hoursOfSunshine: Double
      var id = UUID()

      init(city: String, month: Int, hoursOfSunshine: Double) {
        let calendar = Calendar.autoupdatingCurrent
        self.city = city
        self.date = calendar.date(from: DateComponents(year: 2020, month: month))!
        self.hoursOfSunshine = hoursOfSunshine
      }
    }

    struct ContentView: View {
      var data: [MonthlyHoursOfSunshine] = [
  <<data()>>
      ]
      var body: some View {
        Chart(data) {
          LineMark(
            x: .value("Month", $0.date),
            y: .value("Hours of Sunshine", $0.hoursOfSunshine)
          )
          .foregroundStyle(by: .value("City", $0.city))
        }
        .frame(minWidth: 800, minHeight: 300)
        .padding()
        .colorScheme(.dark)
      }
    }
  ,#+end_src
#+end_src

While I've shown fairly basic usages of noweb, we can accomplish some nifty integrations. Check out the [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb reference syntax]] for more examples and additional header arguments like =tangle=, =strip-tangle=, and others.

* [2023-05-25 Thu] Deleting from Emacs sequence vars
:PROPERTIES:
:CUSTOM_ID: deleting-from-emacs-sequence-vars
:END:
Adding hooks and setting variables is core to customizing Emacs. Take a major mode like
=emacs-lisp-mode= as an example. To customize its behaviour, one may add a hook function to =emacs-lisp-mode-hook=, or if you're a little lazy while experimenting, you may even use a lambda.

#+begin_src emacs-lisp :lexical no
  (add-hook 'emacs-lisp-mode-hook
            #'my/emacs-lisp-mode-config)

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (message "I woz ere")))
#+end_src

=emacs-lisp-mode-hook='s content would subsequently look as follows:

#+begin_src emacs-lisp :lexical no
  '(my/emacs-lisp-mode-config
    (lambda nil
      (message "I woz ere"))
    ert--activate-font-lock-keywords
    easy-escape-minor-mode
    lisp-extra-font-lock-global-mode)
#+end_src

Maybe =my/emacs-lisp-mode-config= didn't work out for us and we'd like to remove it. We can use =remove-hook= for that and evaluate something like:

#+begin_src emacs-lisp :lexical no
  (remove-hook 'emacs-lisp-mode-hook #'my/emacs-lisp-mode-config)
#+end_src

The lambda can be removed too, but you ought to be careful in using the same lambda body.

#+begin_src emacs-lisp :lexical no
  (remove-hook 'emacs-lisp-mode-hook
               (lambda ()
                 (message "I woz tere")))
#+end_src

There are other ways to remove the lambdas, but we're digressing here... We typically have to write these throwaway snippets to undo our experiments. What if we just had a handy helper always available to remove items from sequences /(edit: we do, =remove-hook= is already interactive, see Update 2 below)/? After all, hooks are just lists (sequences).

#+ATTR_HTML: :width 70%
[[file:images/deleting-from-emacs-sequence-vars/removed-lambda.gif]]

While the interactive command can likely be simplified further, I tried to optimize for ergonomic usage. For example, =completing-read= gives us a way narrow down whichever variable we'd like to modify as well as the item we'd like to remove. =seqp= is also handy, as we filter out noise by automatically removing any variable that's not a sequence.

#+begin_src emacs-lisp :lexical no
  (defun ar/remove-from-list-variable ()
    (interactive)
    (let* ((var (intern
                 (completing-read "From variable: "
                                  (let (symbols)
                                    (mapatoms
                                     (lambda (sym)
                                       (when (and (boundp sym)
                                                  (seqp (symbol-value sym)))
                                         (push sym symbols))))
                                    symbols) nil t)))
           (values (mapcar (lambda (item)
                             (setq item (prin1-to-string item))
                             (concat (truncate-string-to-width
                                      (nth 0 (split-string item "\n"))
                                      (window-body-width))
                                     (propertize item 'invisible t)))
                           (symbol-value var)))
           (index (progn
                    (when (seq-empty-p values) (error "Already empty"))
                    (seq-position values (completing-read "Delete: " values nil t)))))
      (unless index (error "Eeek. Something's up."))
      (set var (append (seq-take (symbol-value var) index)
                       (seq-drop (symbol-value var) (1+ index))))
      (message "Deleted: %s" (truncate-string-to-width
                              (seq-elt values index)
                              (- (window-body-width) 9)))))
#+end_src

Hooks are just an example of lists we can delete from. I recently used the same command on =display-buffer-alist=.

#+ATTR_HTML: :width 80%
[[file:images/deleting-from-emacs-sequence-vars/alist.gif]]

While this has been a fun exercise, I can't help but think that I'm likely re-inventing the wheel here. Is there something already built-in that I'm missing?

** Update 1

[[https://www.reddit.com/user/github-alphapapa/][alphapapa]] suggested some generalizations that would provide [[https://www.reddit.com/r/emacs/comments/13rvehx/comment/jlni3fc/?utm_source=share&utm_medium=web2x&context=3][an editing buffer of sorts]]. This is a neat idea, using familiar key bindigs =C-c C-c= to save and =C-c C-k= to bail.

#+ATTR_HTML: :width 70%
[[file:images/deleting-from-emacs-sequence-vars/edit.gif]]

Beware, I haven't tested the code with a diverse set of list items, so there's a chance of corrupting the variable content. Improvements to the code are totally welcome.

#+begin_src emacs-lisp :lexical no
  ;;; -*- lexical-binding: t; -*-

  (defun ar/edit-list-variable ()
    (interactive)
    (let* ((var (intern
                 (completing-read "From variable: "
                                  (let (symbols)
                                    (mapatoms
                                     (lambda (sym)
                                       (when (and (boundp sym)
                                                  (seqp (symbol-value sym)))
                                         (push sym symbols))))
                                    symbols) nil t)))
           (values (string-join
                    (mapcar #'prin1-to-string (symbol-value var))
                    "\n")))
      (with-current-buffer (get-buffer-create "*eval elisp*")
        (emacs-lisp-mode)
        (local-set-key (kbd "C-c C-c")
                       (lambda ()
                         (interactive)
                         (eval-buffer)
                         (kill-this-buffer)
                         (message "Saved: %s" var)))
        (local-set-key (kbd "C-c C-k") 'kill-this-buffer)
        (erase-buffer)
        (insert (format "(setq %s\n `(%s))" var values))
        (mark-whole-buffer)
        (indent-region (point-min) (point-max))
        (deactivate-mark)
        (switch-to-buffer (current-buffer)))))
#+end_src

** Update 2

So hunch was right...

#+BEGIN_QUOTE
"While this has been a fun exercise, I can't help but think that I'm likely re-inventing the wheel here. Is there something already built-in that I'm missing?"
#+END_QUOTE

[[https://www.reddit.com/user/juicecelery/][juicecelery]]'s Reddit commit [[https://www.reddit.com/r/emacs/comments/13rvehx/comment/jlo8mhf/?utm_source=share&utm_medium=web2x&context=3][confirmed it]]. Thank you! [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][remove-hook]] is already interactive ü§¶‚Äç‚ôÇÔ∏è. [[https://knowyourmeme.com/memes/today-i-learned-til][TIL]] üòÅ

juicecelery was kind enough to point out an improvement in the custom function:

#+BEGIN_QUOTE
"but I see your improvements, for instance that non list items are removed from the selection."
#+END_QUOTE
* [2023-05-18 Thu] Sprinkle me logs
:PROPERTIES:
:CUSTOM_ID: sprinkle-me-logs
:END:
At times, basic prints/logs are just about the right debugging strategy. Sure, we have debuggers and [[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPLs]] which are super useful, but sometimes you just know that sprinkling your code with a handful of temporary prints/logs will get you enough info to fix an issue.

I must confess, my temporary print statements are fairly uninspiring. Sometimes I log the name of the method/function, but I also resort to less creative options like =print("Yay")= or =print("Got here")=.

My laziness and lack of creativity knows no boundaries, so if I need multiple unique entries, I often copy, paste, and append numbers to my entries: =print("Yay 2")=, =print("Yay 3")=, =print("Yay 4")=... I know, are you judging yet?

So rather than develop the creative muscle, I've decided to lean on laziness and old habits, so let's make old habit more efficient :) I no longer want to copy, paste, and increment my uncreative log statements. Instead, I'll let Emacs do it for me!

#+ATTR_HTML: :width 70%
[[file:images/sprinkle-me-logs/log-elisp.gif]]

There isn't a whole lot to the implementation. It searches the current buffer for other instances of the same logging string and captures the largest counter found. It subsequently prints the same string with the counter incremented. This can be done in a few lines of elisp, but I figure I wanted some additional features like auto indenting and changing the logging string when using a prefix.

#+begin_src emacs-lisp :lexical no
  (defvar ar/unique-log-word "Yay")

  (defun ar/insert-unique-log-word (prefix)
    "Inserts `ar/unique-log-word' incrementing counter.

  With PREFIX, change `ar/unique-log-word'."
    (interactive "P")
    (let* ((word (cond (prefix
                        (setq ar/unique-log-word
                              (read-string "Log word: ")))
                       ((region-active-p)
                        (setq ar/unique-log-word
                              (buffer-substring (region-beginning)
                                                (region-end))))
                       (ar/unique-log-word
                        ar/unique-log-word)
                       (t
                        "Reached")))
           (config
            (cond
             ((equal major-mode 'emacs-lisp-mode)
              (cons (format "(message \"%s: \\([0-9]+\\)\")" word)
                    (format "(message \"%s: %%s\")" word)))
             ((equal major-mode 'swift-mode)
              (cons (format "print(\"%s: \\([0-9]+\\)\")" word)
                    (format "print(\"%s: %%s\")" word)))
             ((equal major-mode 'ada-mode)
              (cons (format "Ada.Text_Io.Put_Line (\"%s: \\([0-9]+\\)\");" word)
                    (format "Ada.Text_Io.Put_Line (\"%s: %%s\");" word)))
             ((equal major-mode 'c++-mode)
              (cons (format "std::cout << \"%s: \\([0-9]+\\)\" << std::endl;" word)
                    (format "std::cout << \"%s: %%s\" << std::endl;" word)))
             (t
              (error "%s not supported" major-mode))))
           (match-regexp (car config))
           (format-string (cdr config))
           (max-num 0)
           (case-fold-search nil))
      (when ar/unique-log-word
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward match-regexp nil t)
            (when (> (string-to-number (match-string 1)) max-num)
              (setq max-num (string-to-number (match-string 1))))))
        (setq max-num (1+ max-num)))
      (unless (looking-at-p "^ *$")
        (end-of-line))
      (insert (concat
               (if (looking-at-p "^ *$") "" "\n")
               (format format-string
                       (if ar/unique-log-word
                           (number-to-string (1+ max-num))
                         (string-trim
                          (shell-command-to-string
                           "grep -E '^[a-z]{6}$' /usr/share/dict/words | shuf -n 1"))))))
      (call-interactively 'indent-for-tab-command)))
#+end_src

Note: This snippet may evolve independently of this post. For the latest, chech my [[https://github.com/xenodium/dotsies][Emacs config]]'s [[https://github.com/xenodium/dotsies/blob/main/emacs/features/fe-prog.el][fe-prog.el]].

I want to be lazy in other languages, so the function can now be extended to support other languages. Here's the Swift counterpart.

#+ATTR_HTML: :width 70%
[[file:images/sprinkle-me-logs/log-swift.gif]]

Since I sometimes log function names, I figured making it region-aware would help with that.

#+ATTR_HTML: :width 80%
[[file:images/sprinkle-me-logs/log-selection.gif]]

I'm sure there's a package out there that does something similar, but I figure this would be a fun little elisp hack.

Happy logging!

** Update 1

Set =ar/unique-log-word= to nil and let it generate a random word. Maybe I get to learn new words as I debug ;)

#+ATTR_HTML: :width 80%
[[file:images/sprinkle-me-logs/word.gif]]

** Update 2
Added Ada and C++ support, thanks to [[https://www.emacs.dyerdwelling.family/emacs/20230523204523-emacs--insert-unique-log-message/][James Dyer's post]].
* [2023-05-11 Thu] dwim-shell-command on Windows + upload to 0x0.st
:PROPERTIES:
:CUSTOM_ID: dwim-shell-command-now-on-windows
:END:
You can now use [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] on Windows. Shoutout to Kartik Saranathan, who sent a [[https://github.com/xenodium/dwim-shell-command/pull/9][pull request]] to get rid of =ls= usage.

Also thanks to Bram for sharing his [[https://indieweb.social/@bram85@emacs.ch/110335134760990713][upload to 0x0.st implementation]]. I'd been wanting to do something similar for [[https://imgur.com/][imgur]], but [[https://0x0.st/][0x0.st]] is a much better alternative!

#+ATTR_HTML: :width 70%
[[file:images/dwim-shell-command-now-on-windows/0x0.gif]]

=dwim-shell-commands-upload-to-0x0= is now part of [[https://github.com/xenodium/dwim-shell-command/commit/1a896221cc34319582b0921b919638ea2528b0e6][dwim-shell-commands.el]] (the optional part of the package). It has a couple of additional touches:

- Open the uploaded image in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/EWW.html][eww]] browser.
- Automatically copy the upload URL to kill-ring. You're likely gonna share this link, right?

If you're unfamiliar with =dwim-shell-command=, it enables Emacs shell commands with DWIM behaviour:

- Asynchronously.
- Using noweb templates.
- Automatically injecting files (from [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] or other buffers) or kill ring.
- Managing buffer focus with heuristics.
- Showing progress bar.
- Quick buffer exit.
- More reusable history.

In addition to replacing =shell-command= with =dwim-shell-command=, I also use it to bring all sorts of command line utilities to familiar Emacs workflows (in dired or current buffers), without having to remember complex command invocations.

I've covered many of the use-cases before:

- [[https://xenodium.com/emacs-dwim-shell-command/][Emacs DWIM shell-command]]
- [[https://xenodium.com/emacs-password-protect-current-pdf-revisited/][Emacs: Password-protect current pdf (revisited)]]
- [[https://xenodium.com/png-to-icns-emacs-dwim-style/][png to icns (Emacs DWIM style)]]
- [[https://xenodium.com/emacs-dwim-shell-command-multi-language/][Emacs: DWIM shell command (multi-language)]]
- [[https://xenodium.com/dwim-shell-command-on-melpa/][dwim-shell-command on Melpa]]
- [[https://xenodium.com/dwim-shell-command-improvements/][dwim-shell-command improvements]]
- [[https://xenodium.com/dwim-shell-command-video-streams/][dwim-shell-command video streams]]
- [[https://xenodium.com/dwim-shell-command-with-template-prompts/][dwim-shell-command with template prompts]]
- [[https://xenodium.com/dwim-shell-command-usages-pdftotext-and-scp/][dwim-shell-command usages: pdftotext and scp]]
- [[https://xenodium.com/emacs-reveal-in-finder-dwim-style/][Emacs: Reveal in macOS Finder (DWIM style)]]
- [[https://xenodium.com/emacs-macos-share-from-dired-dwim-style/][Emacs: macOS sharing (DWIM style)]]

* [2023-05-01 Mon] chatgpt-shell siblings now on MELPA also
:PROPERTIES:
:CUSTOM_ID: chatgpt-shell-siblings-now-on-melpa-also
:END:
In [[https://xenodium.com/chatgpt-shell-available-on-melpa/][chatgpt-shell updates]], I highlighted =dall-e-shell= (a DALL-E Emacs shell), =ob-chatgpt-shell= (ChatGPT org babel support), and =ob-dall-e-shell= (DALL-E org babel support) were initially excluded from the [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] MELPA submission while I worked out their split.

That's now sorted and the packages are available on MELPA.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-siblings-now-on-melpa-also/melpa-siblings.jpg]]

Here's =ob-chatgpt-shell= and =ob-dall-e-shell= in action.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/babel.png]]

Here's =dall-e-shell=.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/dalle.png]]

* [2023-04-28 Fri] Generating elisp org docs
:PROPERTIES:
:CUSTOM_ID: generating-elisp-org-docs
:END:
[[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]]'s README includes few org tables documenting the package's [[https://github.com/xenodium/chatgpt-shell#chatgpt-shell-customizations][customizable variables]] as well as [[https://github.com/xenodium/chatgpt-shell#chatgpt-shell-commands][available commands]]. Don't worry, this isn't really another ChatGPT post.

Here's an extract of the docs table:

#+begin_src org :lexical no
  | Custom variable                       | Description                                                 |
  |---------------------------------------+-------------------------------------------------------------|
  | chatgpt-shell-display-function        | Function to display the shell.                              |
  | chatgpt-shell-curl-additional-options | Additional options for `curl' command.                      |
  | chatgpt-shell-system-prompt           | The system message helps set the behavior of the assistant. |
#+end_src

While the table docs didn't take long to build manually, they quickly became out of sync with their elisp counterparts. Not ideal, as it'll require a little more careful maintenance in the future.

Emacs being the self-documenting editor that it is, I figured I should be able to extract customizable variables, commands, along with their respective docs, and generate these very same org tables.

I had no idea how to go about this, but [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html][apropos-variable]] and [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html][apropos-command]] surely knew where to fetch the details from. A peak into =apropos.el= quickly got me on my way. Turns out [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Definition-of-mapatoms][mapatoms]] is just what I needed. It iterates over [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html][obarray]], Emacs's symbol table. We can use it to extract the symbols we're after.

Since we're filtering symbols from =chatgpt-shell=, we can start by including only those whose =symbol-name= match "^chatgpt-shell". Out of all matching, we should only keep custom variables. We can use =custom-variable-p= to check for that. This gives us all relevant variables. We can subsequently get each variable's corresponding docs using =(get symbol 'variable-documentation)= and put it into a list.

Now, if we pull our org babel rabbit out of our Emacs magic hat, we can use =:results table= to print the list as an org table. The source block powering this magic trick looks as follows:

#+begin_src org
  ,#+begin_src emacs-lisp :results table :colnames '("Custom variable" "Description")
    (let ((rows))
      (mapatoms
       (lambda (symbol)
         (when (and (string-match "^chatgpt-shell"
                                  (symbol-name symbol))
                    (custom-variable-p symbol))
           (push `(,symbol
                   ,(car
                     (split-string
                      (or (get (indirect-variable symbol)
                               'variable-documentation)
                          (get symbol 'variable-documentation)
                          "")
                      "\n")))
                 rows))))
      rows)
  ,#+end_src
#+end_src

And just like that... we effortlessly get our elisp docs in an org table, straight from Emacs's symbol table.

#+ATTR_HTML: :width 100%
[[file:images/generating-elisp-org-docs/docs.gif]]

It's worth noting that our snippet used =indirect-variable= to resolve aliases but also limited descriptions to the first line in each docstring.

To build a similar table for interactive commands, we can use the following block (also including bindings).

#+begin_src org
  ,#+BEGIN_SRC emacs-lisp :results table :colnames '("Binding" "Command" "Description")
    (let ((rows))
      (mapatoms
       (lambda (symbol)
         (when (and (string-match "^chatgpt-shell"
                                  (symbol-name symbol))
                    (commandp symbol))
           (push `(,(mapconcat
                     #'help--key-description-fontified
                     (where-is-internal
                      symbol shell-maker-mode-map nil nil (command-remapping symbol)) ", ")
                   ,symbol
                   ,(car
                     (split-string
                      (or (documentation symbol t) "")
                      "\n")))
                 rows))))
      rows)
  ,#+END_SRC
#+end_src

#+ATTR_HTML: :width 100%
[[file:images/generating-elisp-org-docs/commands.gif]]

You see? This post wasn't really about ChatGPT. Aren't you glad you stuck around? üòÄ

* [2023-04-25 Tue] LLM bookmarks
:PROPERTIES:
:CUSTOM_ID: llm-bookmarks
:END:
:MODIFIED:
[2023-09-17 Sun]
:END:
- [[https://vineeth.io/posts/2023/new-age-of-magic/][A New Age of Magic]].
- [[https://news.ycombinator.com/item?id=35643219][Bark ‚Äì Text-prompted generative audio model | Hacker News]].
- [[https://news.ycombinator.com/item?id=35942583][Brex‚Äôs Prompt Engineering Guide | Hacker News]].
- [[https://github.com/suno-ai/bark][GitHub - suno-ai/bark: üîä Text-Prompted Generative Audio Model]].
- [[https://blog.rfox.eu/en/Programming/How_to_run_your_own_LLM_GPT.html][How to run your own LLM (GPT)]].
- [[https://promptperfect.jina.ai/][PromptPerfect - Elevate Your Prompts to Perfection with AI Prompt Engineering]].
- [[https://ykgoon.com/running-llm-locally.html][Running LLMs Locally | Y.K. Goon]].
- [[https://sharegpt.com/][ShareGPT: Share your wildest ChatGPT conversations with one click.]].
- [[https://news.ycombinator.com/item?id=35660751][Show HN: Automatic prompt optimizer for LLMs | Hacker News]].
- [[https://fka.gumroad.com/l/art-of-chatgpt-prompting][The Art of ChatGPT Prompting: A Guide to Crafting Clear and Effective Prompts]].
- [[https://fka.gumroad.com/l/the-art-of-midjourney-ai-guide-to-creating-images-from-text][The Art of Midjourney AI: A Guide to Creating Images from Text]].

* [2023-04-25 Tue] chatgpt-shell updates
:PROPERTIES:
:CUSTOM_ID: chatgpt-shell-available-on-melpa
:END:
About a month ago, I posted about an experiment to build [[https://xenodium.com/a-chatgpt-emacs-shell/][a ChatGPT Emacs shell]] using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Prompts.html][comint mode]]. Since then, it's turned into a package of sorts, evolving with [[https://github.com/xenodium/chatgpt-shell/issues?q=is%3Aissue+is%3Aclosed+][user feedback]] and [[https://github.com/xenodium/chatgpt-shell/pulls?q=is%3Apr+is%3Aclosed][pull requests]].

** Now on MELPA

While [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] is a young package still, it seems useful enough to share more widely. As of today, =chatgpt-shell= is [[https://melpa.org/#/chatgpt-shell][available on MELPA]]. Many thanks to [[https://github.com/riscy][Chris Rayner]] for his MELPA guidance to get the package added.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/cyberpunk.gif]]

I'll cover some of the goodies included in the latest =chatgpt-shell=.

** Delegating to Org Babel

=chatgpt-shell= now evaluates Markdown source blocks by delegating to [[https://orgmode.org/worg/org-contrib/babel/][org babel]]. I've had success with a handful of languages. In some instances, some babel headers may need overriding in =chatgpt-shell-babel-headers=.

Here's a Swift execution via babel, showing standard output.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/swift.gif]]

In addition to standard output, =chatgpt-shell= can now render blocks generating images. Here's a rendered SwiftUI layout via [[https://github.com/xenodium/ob-swiftui][ob-swiftui]].

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/swiftui.gif]]

Can also do diagrams. Here's [[https://ditaa.sourceforge.net/][ditaa]] in action.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/ditaa.gif]]

** Renaming blocks

At times, ChatGPT may forget to label source blocks or maybe you just want to name it differently... You can now rename blocks at point.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/rename.gif]]

** Send prompt/region

There are a handful of commands to send prompts from other buffers, including the region. For example =chatgpt-shell-explain-code=.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/explain-region.gif]]

- chatgpt-shell-send-region
- chatgpt-shell-generate-unit-test
- chatgpt-shell-refactor-code
- chatgpt-shell-proofread-doc
- chatgpt-shell-eshell-summarize-last-command-output
- chatgpt-shell-eshell-whats-wrong-with-last-command

** Saving/restoring transcript

You can save your current session to a transcript and restore later.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/restore.gif]]

** History improvements

[[https://www.n16f.net/][Nicolas Martyanoff]] has a great post on [[https://www.n16f.net/blog/making-ielm-more-comfortable/][making IELM More Comfortable]]. A couple of improvements that stood out for me were:


- Making the command history persistent.
- Searching history with =shell-maker-search-history= / =M-r= via =completing-read=.

=shell-maker-search-history=, coupled with your completion framework of choice, can be pretty handy. I happen to use Oleh Krehel's [[https://github.com/abo-abo/swiper][ivy]].

** shell-maker (make your own AI shells)

While ChatGPT is a popular service, there are many others sprouting. Some are cloud-based, others local, proprietary, open source... In any case, it'd be great be able to hook on to them without much overhead. [[https://xenodium.com/a-shell-maker/][shell-maker]] should help with that. The first  =shell-maker= clients are =chatgpt-shell= and =dall-e-shell=.

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/dalle.png]]

While I've built =dall-e-shell=, it'd be great to see what others can do with =shell-maker=. If you wire it up to anything, please get in touch ([[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]]).

** dall-e-shell, ob-chatgpt-shell, and ob-dall-e-shell (on MELPA too)

UPDATE: [[https://indieweb.social/@xenodium/110087011082546281][dall-e-shell]], [[https://indieweb.social/@xenodium/110130580337078002][ob-chatgpt-shell]], and [[https://indieweb.social/@xenodium/110142796865197004][ob-dall-e-shell]] are now available on MELPA also.

You've seen =dall-e-shell= in the previous section. Here's what =ob-chatgpt-shell= and =ob-dall-e-shell= look like in an [[https://orgmode.org/][org mode]] document:

#+ATTR_HTML: :width 70%
[[file:images/chatgpt-shell-available-on-melpa/babel.png]]

** How are you using =chatgpt-shell=?

Whether you are an existing =chatgpt-shell= user, or would like to give things a try, [[https://melpa.org/#/chatgpt-shell][installing from MELPA]] should generally make things easier for ya. As I mentioned, =chatgpt-shell= is a young package still. There are unexplored Emacs integrations out there. I'd love to hear about whatever you come up with ([[https://indieweb.social/@xenodium][Mastodon]] / [[https://twitter.com/xenodium][Twitter]] / [[https://www.reddit.com/user/xenodium][Reddit]] / [[mailto:me__AT__xenodium.com][Email]]).

* [2023-04-22 Sat] Recording and screenshotting windows: the lazy way
:PROPERTIES:
:CUSTOM_ID: recordscreenshot-windows-the-lazy-way
:END:
While there's no substitution for great written documentation, a quick demo can go a long way in conveying what a tool if capable of doing or what a tip/trick can achieve.

If you've read a handful of my posts, you would have come across either a screenshot or a short clip with some demo. Historically, I've used the macOS's built-in utility invoked via =‚åò + Shift + 5=. It does a fine job for screenshots. For video captures, it's got a couple of small quirks.

** Record window

Unlike screenshots, macOS video capture cannot record a specific window. While you can select a region, it's easy to inadvertently include a portion of your wallpaper in the recording. Not a big deal, but I felt posted screencasts could look as clean as their screenshot counterparts if we could record the window alone.

Let's compare grabbing a region vs window alone. I know the clean look may be subjective, but see what I mean?

#+CAPTION: Capture region (includes wallpaper/background)
#+ATTR_HTML: :width 50%
[[file:images/recordscreenshot-windows-the-lazy-way/record-bg.gif]]

#+CAPTION: Capture window only (ahhh, so clean)
#+ATTR_HTML: :width 50%
[[file:images/recordscreenshot-windows-the-lazy-way/record.gif]]

** Cancel recording

macOS has a handy shortcut (=‚åò + Ctrl + Esc=) to stop recording. If you got your demo right, you're done. If not, you have one more step remaining (right click to delete the blooper).

#+ATTR_HTML: :width 40%
[[file:images/recordscreenshot-windows-the-lazy-way/delete.png]]

Also not a huge deal, but I was hoping for a single shortcut to stop recording _and_ also automatically discard. I haven't found one, but would love to hear if otherwise.

** macosrec enters the chat

I wanted more flexibility to build my own recording/screenshotting flows. A command line utility could be quite versatile at that, so I built [[https://github.com/xenodium/macosrec][macosrec]].

=macosrec= enables taking a screenshot or recording a window video entirely from the command line.

#+ATTR_HTML: :width 60%
[[file:images/recordscreenshot-windows-the-lazy-way/macosrec.gif]]

** elisp glues the world

Command line utilities can be invoked in all sorts of ways, but I'm an Emacs nutter so you can see where this is going... I want Emacs key bindings to control the lot.

| C-c _ | Take screenshot of a window |
| C-c ( | Start recording window      |
| C-c ) | Stop recording window       |
| C-c 8 | Abort recording             |

Integrating command line utilities into Emacs and making them quickly accessible seems to have become a full-time hobby of mine. I kid, but it's become a pretty painless process for me. I built [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]] for that. If you've never heard of [[https://en.wikipedia.org/wiki/DWIM][DWIM]], it stands for "Do what I mean". To give you an idea of the kinds of things I'm using DWIM commands for, check the following out:

- dwim-shell-commands-audio-to-mp3
- dwim-shell-commands-bin-plist-to-xml
- dwim-shell-commands-clipboard-to-qr
- dwim-shell-commands-drop-video-audio
- dwim-shell-commands-files-combined-size
- dwim-shell-commands-git-clone-clipboard-url
- dwim-shell-commands-git-clone-clipboard-url-to-downloads
- dwim-shell-commands-image-to-grayscale
- dwim-shell-commands-image-to-icns
- dwim-shell-commands-image-to-jpg
- dwim-shell-commands-image-to-png
- dwim-shell-commands-pdf-password-protect
- dwim-shell-commands-reorient-image
- dwim-shell-commands-resize-gif
- dwim-shell-commands-resize-image
- dwim-shell-commands-resize-video
- dwim-shell-commands-speed-up-gif
- dwim-shell-commands-speed-up-video
- dwim-shell-commands-unzip
- dwim-shell-commands-video-to-gif
- dwim-shell-commands-video-to-optimized-gif
- dwim-shell-commands-video-to-webp

If it ever took you a little while to find the right command incantation to get things right, only to forget all about it next time you need it ([[https://xenodium.com/emacs-ffmpeg-and-macos-alias-commands][I'm looking at you ffmpeg]]), =dwim-shell-command= can help you easily save things for posterity and make them easily accessible in the future.

Since we're talking ffmpeg, here's all it takes to have gif conversion handy:

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-video-to-gif ()
    "Convert all marked videos to gif(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to gif"
     "ffmpeg -loglevel quiet -stats -y -i '<<f>>' -pix_fmt rgb24 -r 15 '<<fne>>.gif'"
     :utils "ffmpeg"))
#+end_src

There's no way I'll remember the ffmpeg command, but I can always fuzzy search my trusty commands with something like ="to gif"= and apply to either the current buffer file or any selected [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] files.

#+ATTR_HTML: :width 60%
[[file:images/recordscreenshot-windows-the-lazy-way/to-gif.png]]

So where am I going with this? I wrote DWIM shell commands for the bindings I previously described:

| C-c _ | =dwim-shell-commands-macos-screenshot-window=      |
| C-c ( | =dwim-shell-commands-macos-start-recording-window= |
| C-c ) | =dwim-shell-commands-macos-end-recording-window=   |
| C-c 8 | =dwim-shell-commands-macos-abort-recording-window= |

Out of all of commands, =dwim-shell-commands-macos-start-recording-window= is likely the most interesting one.

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-commands-macos-start-recording-window ()
    "Select and start recording a macOS window."
    (interactive)
    (let* ((window (dwim-shell-commands--macos-select-window))
           (path (dwim-shell-commands--generate-path "~/Desktop" (car window) ".mov"))
           (buffer-file-name path) ;; override so <<f>> picks it up
           (inhibit-message t))
      (dwim-shell-command-on-marked-files
         "Start recording a macOS window."
         (format
          "# record .mov
           macosrec --record '%s' --mov --output '<<f>>'
           # speed .mov up x1.5
           ffmpeg -i '<<f>>' -an -filter:v 'setpts=1.5*PTS' '<<fne>>_x1.5.<<e>>'
           # convert to gif x1.5
           ffmpeg -loglevel quiet -stats -y -i '<<fne>>_x1.5.<<e>>' -pix_fmt rgb24 -r 15 '<<fne>>_x1.5.gif'
           # speed .mov up x2
           ffmpeg -i '<<f>>' -an -filter:v 'setpts=2*PTS' '<<fne>>_x2.<<e>>'
           # convert to gif x2
           ffmpeg -loglevel quiet -stats -y -i '<<fne>>_x2.<<e>>' -pix_fmt rgb24 -r 15 '<<fne>>_x2.gif'"
          (cdr window))
         :silent-success t
         :monitor-directory "~/Desktop"
         :no-progress t
         :utils '("ffmpeg" "macosrec"))))
#+end_src

As you likely expect, this command invokes =macosrec= to start recording a window. The nifty part is that when it's done recording (and saving the .mov file), it automatically creates multiple variants. For starters, it creates x1.5 and x2 .mov videos, but it also generates their .gif counterparts.

#+ATTR_HTML: :width 60%
[[file:images/recordscreenshot-windows-the-lazy-way/bunch.png]]

Let's recap here for a sec. You start recording a window video with =C-c (=, end with =C-c )=, and automagically have all these generated files waiting for you.

You can subsequently inspect any of the video candidates and pick the most appropriate variant. Discard whatever else you don't need.

The output bundle is tailored to my needs. Maybe you want to invoke [[https://www.lcdf.org/gifsicle/][gifsycle]] for more optimized versions? Or maybe you want automatic webp generation via =ffmpeg=? DWIM does that I mean, so you likely have other plans...

=dwim-shell-commands-macos-start-recording-window= and all other DWIM commands are now included in [[https://github.com/xenodium/dwim-shell-command/blob/main/dwim-shell-commands.el][dwim-shell-commands.el]], which ships optionally as part of [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]].

[[https://github.com/xenodium/macosrec][macosrec]] is also on GitHub, but if you want to be on your way, you can install via:

#+begin_src sh
  brew tap xenodium/macosrec
  brew install macosrec
#+end_src

This is my way to record and screenshot windows the lazy way. How would you tweak to make it yours?

* [2023-04-20 Thu] ob-swiftui updates
:PROPERTIES:
:CUSTOM_ID: ob-swiftui-updates
:END:
While [[https://indieweb.social/@xenodium/110227186721704189][experimenting with delegating Markdown]] blocks to [[https://orgmode.org/worg/org-contrib/babel/][Org babel]] in Emacs [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]], I resurrected [[https://github.com/xenodium/ob-swiftui][ob-swiftui]]. A package I had written to execute and render SwiftUI blocks in org babel.

[[https://github.com/xenodium/ob-swiftui][ob-swiftui]] has two modes of rendering SwiftUI blocks: =:results window=, which runs outside of Emacs in a native window and =:results file=, which renders and saves to a file. The latter can be viewed directly from Emacs.

=:results file= was a little clunky. That is, it hardcoded dimensions I had to manually modify if the canvas wasn't big enough. It was also a little slow.

The clunkyness really came through with my chatgpt-shell experiments, so I took a closer look and made a few changes to remove hardcoding and speeds things up.

The results ain't too shabby.

#+ATTR_HTML: :width 80%
[[file:images/ob-swiftui-updates/file-render.gif]]

Another tiny improvement is that if you'd like to compose a more complex layout made of multiple custom views, =ob-swiftui= now looks for a =ContentView= as that root view by default. Specifying another root view was already possible but it had to be explicitly requested via =:view= param.

You can now omit the =:view= param if you name the root view =ContentView=:

#+begin_src org
  ,#+begin_src swiftui
    struct ContentView: View {
      var body: some View {
          TopView()
          BottomView()
      }
    }

    struct TopView: View {
      var body: some View {
        Text("Top text")
      }
    }

    struct BottomView: View {
      var body: some View {
        Text("Bottom text")
      }
    }
  ,#+end_src
#+end_src

The improvements have been pushed to [[https://github.com/xenodium/ob-swiftui][ob-swiftui]] and will soon be picked up on [[https://melpa.org/#/ob-swiftui][melpa]].

Edit: Added ContentView details.

* [2023-04-15 Sat] My Emacs eye candy
:PROPERTIES:
:CUSTOM_ID: my-emacs-eye-candy
:END:
I get the occasional question about my Emacs theme, font, and other eye candy. I'm always tickled and happy to share.
#+ATTR_HTML: :width 80%
[[file:images/my-emacs-eye-candy/Emacs.png]]

It's been a while since I've made visually significant changes to my Emacs config. May as well briefly document for posterity...

** Nyan Mode
First things first. The adorable and colorful little fella in my mode line is a [[https://en.wikipedia.org/wiki/Nyan_Cat][Nyan Cat]] (if you dare, check the [[https://www.youtube.com/watch?v=QH2-TGUlwu4][meme video]]). Yes, I know it's sooo 2011, but it's 2023 and I still love the little guy hanging out in my Emacs mode line. I still get asked about it.

#+ATTR_HTML: :height 30px
[[file:images/my-emacs-eye-candy/Nyan.png]]

This fabulous feature comes to us via the great [[https://github.com/TeMPOraL/nyan-mode/][Nyan Mode]] package. If looks haven't convinced you, Nyan also packs scrolling functionality. Click anywhere in it.

Oh, and if you can't get enough of Nyan, there's also [[https://depp.brause.cc/zone-nyan/][zone-nyan]] for Emacs.

** Emacs Plus (macOS)
I should mention I'm running Emacs 28 on macOS via the excellent [[https://github.com/d12frosted/homebrew-emacs-plus][Emacs Plus]] [[https://brew.sh/][homebrew]] recipe. These are all the options I enable.

#+begin_src sh
  brew install  emacs-plus@28 --with-imagemagick --with-no-frame-refocus --with-native-comp --with-savchenkovaleriy-big-sur-icon
#+end_src

*** Icon
Since we're talking eye candy, let's chat about =--with-savchenkovaleriy-big-sur-icon=. This Emacs Plus option enables Valeriy Savchenko's [[https://github.com/SavchenkoValeriy/emacs-icons][wonderful icon]].

#+ATTR_HTML: :width 50%
[[file:images/my-emacs-eye-candy/swap.png]]

*** Titlebar
I've enabled both transparent title bar as well as dark appearance, giving a minimal window decoration.

#+ATTR_HTML: :width 60%
[[file:images/my-emacs-eye-candy/decoration.jpg]]

#+begin_src emacs-lisp :lexical no
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src

Note: both of these variables are prefixed =ns-= (macOS-only settings).

** Font (JetBrains Mono)

I've been on [[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font for quite some time now. In the past, I've also been a fan of [[https://madmalik.github.io/mononoki/][Mononoki]] and [[https://en.wikipedia.org/wiki/Menlo_(typeface)][Menlo]] (on macOS) or [[https://github.com/andreberg/Meslo-Font][Meslo]] (similar elsewhere).

** Theme (Material)

I'm using the great [[https://github.com/cpaulik/emacs-material-theme][Material Theme for Emacs]], with a [[https://github.com/xenodium/dotsies/blob/790465b1824481b81bf5c6e08949128c13d76f95/emacs/features/fe-ui.el#L42][bunch of tweaks of my own]].

** Modeline tabs/ribbons (Moody)

The [[https://github.com/tarsius/moody][moody]] package adds a nice touch displaying mode line elements as tabs and ribbons.

** Modeline menus (Minions)

The [[https://github.com/tarsius/minions][minions]] package removes lots of minor mode clutter from the mode line and stashes it away in menus.

** Hiding modeline (hide mode line mode)

Hiding the mode line isn't something I use in most major modes. However, I found it complements my shell ([[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][eshell]]) quite well. While I was sceptical at first, once I hid the mode line in my shell I never looked back. I just didn't miss it. I also love the uncluttered clean vibe. [[https://github.com/hlissner/emacs-hide-mode-line][hide-mode-line-mode]] can help with that.

#+ATTR_HTML: :width 50%
[[file:images/my-emacs-eye-candy/eshell.gif]]

** Welcome screen

Back in October 2022, I experimented with [[https://xenodium.com/emacs-a-welcoming-experiment/][adding a minimal welcome screen]]. I was initially hesitant, as I was already a fan of the welcome scratch buffer. In any case, I figured I'd eventually get tired of it and remove it. Well, it's enabled in my config still ;) My initial attachment to a landing scratch quickly faded. I'm only a =C-x b= binding away from invoking ivy-switch-buffer to get me anywhere.

#+ATTR_HTML: :width 80%
[[file:images/my-emacs-eye-candy/welcome.png]]

The great Emacs logo originally [[https://www.reddit.com/r/unixporn/comments/yamj5f/exwm_emacs_is_kinda_comfy_as_a_wm/][shared by u/pearcidar43]].

** Zones

I've been meaning to re-enable [[https://github.com/emacs-mirror/emacs/blob/master/lisp/play/zone.el][zones]] in my config. They always gave me a good tickle. I've already mentioned [[https://depp.brause.cc/zone-nyan/][zone-nyan]], but if you're new to zones, they kick off after a period of inactivity (similar to a screensaver).

Here's =zone-pgm-rotate= in all its glory. Oh and it's built-in!

#+ATTR_HTML: :width 80%
[[file:images/my-emacs-eye-candy/rotate.webp]]

Coincidentally, I had a go at writing [[https://xenodium.com/emacs-zones-to-lift-you-up/][a basic zone a little while ago]].

#+ATTR_HTML: :width 80%
[[file:images/my-emacs-eye-candy/zone.gif]]

** Config

Most of the items mentioned I pulled from my [[https://github.com/xenodium/dotsies][Emacs config]]'s [[https://github.com/xenodium/dotsies/blob/main/emacs/features/fe-ui.el][fe-ui.el]]. There's more there if you're interested.

What is some of your favorite Emacs eye candy? [[https://www.reddit.com/r/emacs/comments/12nbb9x/my_emacs_eye_candy/][reddit]] / [[https://indieweb.social/@xenodium/110204024063552954][mastodon]] / [[https://twitter.com/xenodium/status/1647293089394900993][twitter]].

* [2023-04-08 Sat] shell-maker, a maker of Emacs shells
:PROPERTIES:
:CUSTOM_ID: a-shell-maker
:END:
A few weeks ago, I wrote about an experiment to bring [[https://xenodium.com/a-chatgpt-emacs-shell/][ChatGPT to Emacs as a shell]]. I was fairly new to both [[https://openai.com/blog/chatgpt][ChatGPT]] and building anything on top of [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Prompts.html][comint]]. It was a fun exercise, which also generated some interest.

As mentioned in the previous post, I took inspiration in other Emacs packages (primarily [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Interaction.html][ielm]]) to figure out what I needed from comint. Soon, I got ChatGPT working.

#+ATTR_HTML: :width 80%
[[file:images/a-shell-maker/streamer.gif]]

As I was looking at [[https://openai.com][OpenAI]] API docs, I learned about DALL-E: "an AI system that can create realistic images and art from a description in natural language."

Like ChatGPT, they also offered an API to DALL-E, so I figured I may as well try to write a shell for that too... and I did.

#+ATTR_HTML: :width 60%
[[file:images/a-shell-maker/dalle.gif]]

There was quite a bit of code duplication between the two Emacs shells I had just written. At the same time, I started hearing from folks about integrating other tools, some cloud-based, some local, proprietary, open source.. There's [[https://about.sourcegraph.com/cody][Cody]], [[https://github.com/invoke-ai/InvokeAI][invoke-ai]],  [[https://github.com/ggerganov/llama.cpp][llama.cpp]], [[https://github.com/antimatter15/alpaca.cpp][alpaca.cpp]], and the list continues to grow.

With that in mind, I set out to reduce the code duplication and consolidate into a reusable package. And so =shell-maker= was born, a maker of Emacs shells.

=shell-maker='s internals aren't too different from the code I had before. It's still powered by comint, but instead offers a reusable convenience wrapper.

It takes little code to implement a shell, like the sophisticated new =greeter-shell= ;)

#+ATTR_HTML: :width 60%
[[file:images/a-shell-maker/maria.gif]]

#+begin_src emacs-lisp
  (require 'shell-maker)

  (defvar greeter-shell--config
    (make-shell-maker-config
     :name "Greeter"
     :execute-command
     (lambda (command _history callback error-callback)
       (funcall callback
                (format "Hello \"%s\"" command)
                nil))))

  (defun greeter-shell ()
    "Start a Greeter shell."
    (interactive)
    (shell-maker-start greeter-shell--config))
#+end_src

[[https://github.com/xenodium/chatgpt-shell#shell-maker][shell-maker]] is available on GitHub and currently bundled with [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]]. If there's enough interest and usage, I may just break it out into its own package. For now, it's convenient to keep with =chatgpt-shell= and =dall-e-shell=.

If you plug =shell-maker= into other tools, I'd love to hear about it.

Happy shell making!

* [2023-04-06 Thu] Flat Habits 1.1.4 released
:PROPERTIES:
:CUSTOM_ID: flat-habits-114-released
:END:

[[https://flathabits.com/][Flat Habits]] 1.1.4 is now available on the [[https://apps.apple.com/app/id1558358855][App Store]].

Flat Habits is a habit tracker that‚Äôs mindful of your time, data, and privacy. It's a simple but effective iOS app.

#+BEGIN_EXPORT html
<div style="text-align: center;">
  <img src="https://flathabits.com/intro_thumbnail.jpg" alt="today_no_filter.png" width="90%">
  <br/>
  <br/>
  <a href="https://apps.apple.com/app/id1558358855">
    <img src="../images/flat-habits-for-ios/download-on-app-store.png" alt="download-on-app-store.png" height="40px">
