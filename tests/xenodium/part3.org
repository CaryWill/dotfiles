
  (defun plainorg--snapshot-override-image (old-buffer old new-buffer new destination)
    (let ((window-configuration (current-window-configuration))
          (action)
          (result))
      (unwind-protect
          (progn
            (delete-other-windows)
            (split-window-horizontally)
            (switch-to-buffer (with-current-buffer (get-buffer-create old-buffer)
                                (let ((inhibit-read-only t))
                                  (erase-buffer))
                                (insert-file-contents old)
                                (image-mode)
                                (current-buffer)))
            (switch-to-buffer-other-window (with-current-buffer (get-buffer-create new-buffer)
                                             (let ((inhibit-read-only t))
                                               (erase-buffer))
                                             (insert-file-contents new)
                                             (image-mode)
                                             (current-buffer)))
            (while (null result)
              (setq action (read-char-choice (format "Override %s? (y)es (n)o (d)iff in browser? "
                                                     (file-name-base old))
                                             '(?y ?n ?d ?q)))
              (cond ((eq action ?n)
                     (setq result
                           (format "Keeping old %s" (file-name-base old))))
                    ((eq action ?y)
                     (copy-file new old t)
                     (setq result
                           (format "Overriding old %s" (file-name-base old))))
                    ((eq action ?d)
                     (shell-command (format "open -a Firefox %s --args --new-tab" old))
                     (shell-command (format "open -a Firefox %s --args --new-tab" new)))
                    ((eq action ?q)
                     (set-window-configuration window-configuration)
                     (setq result (format "Quit %s" (file-name-base old)))))))
        (set-window-configuration window-configuration)
        (kill-buffer old-buffer)
        (kill-buffer new-buffer))
      result))
#+end_src

* [2021-11-10 Wed] Plain Org has joined the chat (iOS)
:PROPERTIES:
:CUSTOM_ID: plain-org-has-joined-the-chat
:END:
The App Store is a crowded space when it come to markdown apps. A quick search yields a wonderful wealth of choice. Kinda overwhelming, but a great problem to have nonetheless.

For those of us with org as our markup of choice, the App Store is far less crowded. I wish we could fill more than a screen's worth of search results, so you know... I could show you another pretty gif scrolling through org results. For now, we'll settle on a single frame showcasing our 4 org options.

#+ATTR_HTML: :width 80%
[[file:images/plain-org-has-joined-the-chat/store-side-comparison-mid.gif]]

[[https://beorg.app/][Beorg]], [[http://mobileorg.github.io/][MobileOrg]], [[https://flathabits.com/][Flat Habits]], and [[https://orgro.org/][Orgro]] are all great options. Each with strengths of their own. [[https://organice.200ok.ch/][Organice]], while not on the App Store, is another option for those looking for a web alternative. Of these, I had already authored one of them. More on that in a sec... You see, about a year ago I wanted to play with Swift, SPM, and lsp itself. Also, having Swift code completion in Emacs via [[https://github.com/emacs-lsp/lsp-sourcekit][lsp-sourcekit]] sounded like a fun thing to try out, so I started using it while writing a Swift org parser.

#+ATTR_HTML: :width 75%
[[file:images/plain-org-has-joined-the-chat/magit.png]]

While working on the parser, I happened to be reading [[https://jamesclear.com/atomic-habits][Atomic Habits]] (awesome book btw)... It was also a great time to play around with SwiftUI, which by the way, is pretty awesome too. With Atomic Habits fresh in mind, org parser in one hand, and SwiftUI in the other, I built [[https://flathabits.com][Flat Habits]]: a lightweight habit tracker powered by org.

#+ATTR_HTML: :width 80% :height 80%
[[file:images/frictionless-org-habits-on-ios/flat_habits.gif]]

I love being able to save habit data to plain text and easily track on my iPhone (via Flat Habits) or laptop (via Emacs). I wanted to [[https://xenodium.com/org-habits-on-ios-check-tasks-youre-next/][extend similar convenience to org tasks]], so I built [[https://plainorg.com][Plain Org]].

My previous [[https://xenodium.com/org-habits-on-ios-check-tasks-youre-next/][post]] mentioned /quickly adding new tasks and searching existing ones/ as Plain Org's driving goals. Of course, neither of those are as useful without automatic cloud syncing, so pluging into [[https://support.apple.com/en-gb/HT206481#thirdparty][iOS's third party cloud support]] was a must-have.

With these baseline features in place, I [[https://www.reddit.com/r/orgmode/comments/p5bonn/ios_plain_org_alpha_builds_now_on_testflight_dm/][started an alpha/beta group]] via [[https://testflight.apple.com/][TestFlight]]. Early Plain Org adopters have been wonderfully supportive, given lots of great feedback, and helped shape the initial feature set you see below.

/There's plenty more that can be supported, but hey let's get v1 out the door. Gotta start somewhere./

** Plain Org v1 features

- View and edit your org mode tasks while on the go.
- Beautifully rendered org markup.
- Sync your org files using your favorite cloud provider.
- Create new files.
- Outline-style editing with toolbar
    - Keywords
    - Indent
    - Priority
    - Tags
    - Formatting: bold, italic, underline, strikethrough, verbatim, and code.
- Add links from Safari via share extension.
- Add new tasks via Spotlight.
- Reorder headings via drag/drop.
- Checkboxes
    - Interactive toggling.
    - Quickly reset multiple checkboxes.
- Follow local links.
- Show inline images.
- File-local keywords and visibility.
- Filter open/closed tasks.
- Show/hide stars.
- Edit raw text.
- Light/dark mode.

** Plain Org joins the chat
Today Plain Org joins the likes of [[https://beorg.app/][Beorg]], [[http://mobileorg.github.io/][MobileOrg]], [[https://flathabits.com/][Flat Habits]], and [[https://orgro.org/][Orgro]] on the App Store.

#+ATTR_HTML: :width 50%
[[file:images/plain-org-has-joined-the-chat/intro.png]]

#+BEGIN_EXPORT html
<br/>
<div style="text-align: center;">
  <a href="https://apps.apple.com/app/id1578965002">
    <img src="../images/flat-habits-for-ios/download-on-app-store.png" alt="download-on-app-store.png" height="40px">
  </a>
</div>
#+END_EXPORT

#+BEGIN_EXPORT html
<p style="text-align: center;">
  This post was written in   <a href="https://orgmode.org">org mode</a>.
</p>
#+END_EXPORT

* [2021-09-19 Sun] Plain Org for iOS (a month later)
  :PROPERTIES:
  :CUSTOM_ID: plain-org-for-ios-a-month-later
  :END:
A month ago, I posted about my desire to [[https://xenodium.com/org-habits-on-ios-check-tasks-youre-next/][bring org tasks/TODOs to iOS]] and make them quickly available from my iPhone.

Since then, I've received some great feedback, which I've been slowly chipping away at. My intent isn't so much to move my org workflow over to iOS, but to supplement Emacs while away from my laptop.

As of now, this is what the inline edit experience looks like:

#+ATTR_HTML: :width 50% :height 50%
[[file:images/plain-org-for-ios-a-month-later/inline_keyword_toolbar.gif]]

If, like me, you prefer dark mode. The app's got ya covered:

#+ATTR_HTML: :width 50% :height 50%
[[file:images/plain-org-for-ios-a-month-later/dark.png]]

/Plain Org/ is not yet available on the App Store, but you can get a TestFlight invite if you send me an email address. Ping me on [[https://www.reddit.com/user/xenodium][reddit]], [[https://twitter.com/xenodium][twitter]], or email me at "plainorg" + "@" + "xenodium.com".

You can also check out progress over at the [[https://www.reddit.com/r/plainorg/][r/plainorg]] subreddit.

* [2021-08-19 Thu] Org habits on iOS? Check! Tasks, you're next
:PROPERTIES:
:CUSTOM_ID: org-habits-on-ios-check-tasks-youre-next
:END:
I'm an [[https://orgmode.org][org mode]] fan. This blog is powered by org. It's more of an accidental blog that started as a [[https://github.com/xenodium/xenodium.github.io/blob/master/index.org][single org file]] keeping notes. I use [[https://orgmode.org/worg/org-contrib/babel/intro.html][org babel]] too. Oh and [[https://orgmode.org/manual/Tracking-your-habits.html][org habits]]. My never-ending list of TODOs is also powered by org. I manage all of this from Emacs and peek at TODOs using [[https://orgmode.org/manual/Agenda-Views.html][org agenda]]. This all works really well while I'm sitting in front of my laptop running Emacs.

But then I'm away from my laptop... and I need to quickly record habits on the go. I need it to be low-friction. Ssh'ing to an Emacs instance from a smartphone isn't an option. I'm an iPhone user, so whatever the solution, it should play nice with Emacs and org mode. I built [[https://flathabits.com][Flat Habits]] for habit tracking and I'm fairly happy with the result. As of today, my longest-tracked habit is on a 452-day streak.

#+ATTR_HTML: :width 80% :height 80%
[[file:images/frictionless-org-habits-on-ios/flat_habits.gif]]

Moving on to org tasks/TODOs... I want something fairly frictionless while on the go. With /Flat Habits/ as a stepping stone, I can now reuse some parts to build [[https://reddit.com/r/plainorg][Plain Org]]. This new app should give me quick access to my tasks. The two driving goals are: quickly add new tasks and search existing ones while away from my laptop. Ok, maybe basic editing helps too. Oh and it should sync over cloud, of course.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/org-habits-on-ios-check-tasks-youre-next/plainorgdemo.gif]]

I now have an early implementation of sorts, [[https://www.reddit.com/r/plainorg/comments/p5bnji/ios_more_improvements_alpha_builds_now_on/][available on TestFlight]]. If you'd like to give it a try, /send me an email address/ to receive the the invite. Ping me on [[https://reddit.com/u/xenodium][reddit]], [[https://twitter.com/xenodium][twitter]], or email me at "plainorg" + "@"  + "xenodium.com".

* [2021-07-11 Sun] Flat Habits 1.1 released
:PROPERTIES:
:CUSTOM_ID: flat-habits-11-released
:END:
[[https://flathabits.com/][Flat Habits]] 1.1 is now available on the [[https://apps.apple.com/app/id1558358855][App Store]]. Flat Habits is a habit tracker that’s mindful of your time, data, and privacy. It's powered by [[https://orgmode.org][org]] plain text markup, enabling you to use your [[https://xenodium.com/frictionless-org-habits-on-ios/][favorite editor]] (Emacs, Vim, VSCode, etc.) to poke at your habit data.

** What's new?

This release implements a few of features requested by users.

** Multiday weekly habits

This is the chunkiest addition and most requested feature. You can now select multiple days when scheduling weekly habits.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/flat-habits-11-released/multi_day_creation.gif]]

#+ATTR_HTML: :width 50% :height 50%
[[file:images/flat-habits-11-released/multi_day_calendar.png]]

** Historical management

Sometimes you forget to mark a habit done or make a mistake toggling one. Either way, you can now toggle any habit day from the calendar/streak view.

*** Long tap

Long tap shows you the editing option available for that day.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/flat-habits-11-released/long_tap.gif]]

*** Short tap

Short tap typically toggles between "Done" and "Not done".

#+ATTR_HTML: :width 50% :height 50%
[[file:images/flat-habits-11-released/short_tap.gif]]

** Where's today?

A few folks rightfully asked for today's date to be highlighted in the calendar view, and so we now have a red circle.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/flat-habits-11-released/today.png]]

** Improved error messages

Hopefully you don't run into issues, but if you do, I hope the app helps ya sort them out.

** Bugfixes

- Tapping on blur now dismisses habit edit dialog.
- Future habits now longer editable.
- Skipped habits no longer have a default tap action.
- Undoing from streak/calendar view now refreshes correctly.
- Undoing habit addition on iPad removes streak/calendar view.
* [2021-07-11 Sun] macOS: Show in Finder / Show in Emacs
:PROPERTIES:
:CUSTOM_ID: show-in-finder--show-in-emacs
:END:

From Christian Tietze's [[https://christiantietze.de/posts/2021/07/open-finder-window-in-dired/][Open macOS Finder Window in Emacs Dired]], I learned about [[https://github.com/kaz-yos/reveal-in-osx-finder][reveal-in-osx-finder]]. This is handy for the few times I want to transition from Emacs to Finder for file management. I say few times since Emacs's directory editor, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]], is just awesome. I've written about dired customizations [[https://xenodium.com/showhide-emacs-dired-details-in-style/][here]] and [[https://xenodium.com/showhide-emacs-dired-details-in-style/][here]], but since dired is /just another buffer,/ you can apply your Emacs magic like multiple cursors to [[https://xenodium.com/batch-renaming-with-counsel-find-dired-and-wdired/][batch rename files in an editable dired buffer]].

To transition from macOS Finder to Emacs, Christian offers an Emacs interactive command that fetches Finder's location and opens a dired buffer via AppleScript. On a similar note, I learned from redditor [[https://www.reddit.com/user/pndc/][u/pndc]] that [[https://www.reddit.com/r/emacs/comments/ohgz0s/open_macos_finder_windows_path_in_dired/h4p8a8f?utm_source=share&utm_medium=web2x&context=3][Finder's proxy icons can be dragged over to Emacs]], which handily drops ya into a dired buffer.

With these two solutions in mind, I looked into a third one to offer a context menu option in Finder to show the file in Emacs. This turned out to be fairly easy using Automator, which I've rarely used.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/show-in-finder--show-in-emacs/show_in_emacs.gif]]

I created a flow that runs a shell script to "Show in Emacs", revealing the selected file or folder in an dired buffer. This is similar to Christian's solution, but invoked from Finder itself. The flow also uses /dired-goto-file/ which moves the point (cursor) to the file listed under dired.

#+ATTR_HTML: :width 98% :height 98%
[[file:images/show-in-finder--show-in-emacs/show_in_emacs.png]]

#+begin_src sh
  current_dir=$(dirname "$1")
  osascript -e 'tell application "Emacs" to activate'
  path/to/emacsclient --eval "(progn (dired \"$current_dir\") (dired-goto-file \"$1\"))"
#+end_src

As a bonus, I added an "Open in Emacs" option, which does as it says on the tin. Rather than show the file listed in a dired buffer, it gets Emacs to open it in your favorite major mode. This option is not technically needed since Finder already provides an "Open With" context menu, but it does remove a few click here and there.

#+ATTR_HTML: :width 98% :height 98%
[[file:images/show-in-finder--show-in-emacs/open_in_emacs.png]]

#+begin_src sh
  osascript -e 'tell application "Emacs" to activate'
  /Users/alvaro/homebrew/bin/emacsclient --eval "(find-file \"$1\")"
#+end_src

On a side note, Emacs defaults to creating new frames when opening files via "Open With" menu (or "open -a Emacs foo.txt"). I prefer to use my existing Emacs frame, which can be accomplished by setting ns-pop-up-frames to nil.

#+begin_src emacs-lisp :lexical no
  (setq ns-pop-up-frames nil)
#+end_src

* [2021-06-27 Sun] Emacs: smarter search and replace
:PROPERTIES:
:CUSTOM_ID: emacs-smarter-search-and-replace
:END:
#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-smarter-search-and-replace/smarter_replace.gif]]

Not long ago, I made a note to go back and read [[https://mac4translators.blogspot.com][Mac for Translators]]'s [[https://mac4translators.blogspot.com/2021/06/regex-with-elisp.html][Emacs regex with Emacs lisp]] post. The author highlights Emacs's ability to apply additional logic when replacing text during a search-and-replace session. It does so by leveraging elisp expressions.

Coincidentally, a redditor recently asked [[https://www.reddit.com/r/emacs/comments/o878am/what_is_the_simplest_way_to_apply_a_math_formula/][What is the simplest way to apply a math formula to all numbers in a buffer/region?]] Some of the answers also point to /search and replace/ leveraging elisp expressions.

While I rarely need to apply additional logic when replacing matches, it's nice to know we have options  available in our Emacs toolbox. This prompted me to check out [[https://github.com/emacs-mirror/emacs/blob/b8f9e58ef72402e69a1f0960816184d52e5d2d29/lisp/replace.el#L709][replace-regexp]]'s documentation (via M-x [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Name-Help.html][describe-function]] or my favorite M-x [[https://github.com/Wilfred/helpful][helpful-callable]]). There's lots in there. Go check its docs out. You may be pleasantly surprised by all the features packed under this humble function.

For instance, \& expands to the current match. Similarly, \#& expands to the current match, fed through [[https://www.gnu.org/software/emacs/manual/html_node/elisp/String-Conversion.html][string-to-number]]. But what if you'd like to feed the match to another function? You can use \, to signal evaluation of an elisp expression. In other words, you could multiply by 3 using \,(* 3 \#&) or inserting whether a number is odd or even with something like \,(if (oddp \#&) "(odd)" "(even)").

Take the following text:

#+begin_example
  1
  2
  3
  4
  5
  6
#+end_example

We can label each value "(odd)" or "(even)" as well as multiply by 3, by invoking /replace-regexp/ as follows:

#+begin_quote
  M-x replace-regexp
#+end_quote

[PCRE] Replace regex:
#+begin_quote
  [-0-9.]+
#+end_quote

Replace regex [-0-9.]+:
#+begin_quote
  \& \,(if (oddp \#&) "(odd)" "(even)") x 3 = \,(* 3 \#&)
#+end_quote

#+begin_example
  1 (odd) x 3 = 3
  2 (even) x 3 = 6
  3 (odd) x 3 = 9
  4 (even) x 3 = 12
  5 (odd) x 3 = 15
  6 (even) x 3 = 18
#+end_example

It's worth noting that /replace-regexp/'s cousin [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html][query-replace-regexp]] also handles all this wonderful magic.

Happy searching and replacing!

* [2021-06-20 Sun] Previewing SwiftUI layouts in Emacs (revisited)
:PROPERTIES:
:CUSTOM_ID: previewing-swiftui-layouts-in-emacs-revisited
:END:
Back in May 2020, I shared a snippet to extend [[https://github.com/zweifisch/ob-swift][ob-swift]] to [[https://xenodium.com/swiftui-layout-previews-using-emacs-org-blocks/][preview SwiftUI layouts using Emacs org blocks]].

#+ATTR_HTML: :width 75% :height 75%
[[file:images/swiftui-layout-previews-using-emacs-org-blocks/ob-swiftui.gif]]

When I say extend, I didn't quite modify ob-swift itself, but rather [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advised]] [[https://github.com/zweifisch/ob-swift/blob/ed478ddbbe41ce5373efde06b4dd0c3663c9055f/ob-swift.el#L37][org-babel-execute:swift]] to modify its behavior at runtime.

Fast-forward to June 2021 and Scott Nicholes [[https://github.com/zweifisch/ob-swift/issues/4#issuecomment-858196354][reminded me there's still interest]] in org babel SwiftUI support. ob-swift [[https://github.com/zweifisch/ob-swift/commits/master][seems a little inactive]], but no worries there. The package offers great general-purpose Swift support. On the other hand, SwiftUI previews can likely live as a single-purpose package all on its own... and so I set off to bundle the rendering functionality into a new [[https://github.com/xenodium/ob-swiftui][ob-swiftui]] package.

Luckily, org babel's documentation has a straightforward section to help you [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][develop support for new babel languages]]. They simplified things by offering [[https://code.orgmode.org/bzg/worg/raw/master/org-contrib/babel/ob-template.el][template.el]], which serves as the foundation for your language implementation. For the most part, it's a matter of searching, replacing strings, and removing the bits you don't need.

The elisp core of ob-swiftui is fairly simple. It expands the org block body, inserts the expanded body into a temporary buffer, and finally feeds the code to the Swift toolchain for execution.

#+begin_src emacs-lisp
  (defun org-babel-execute:swiftui (body params)
    "Execute a block of SwiftUI code in BODY with org-babel header PARAMS.
  This function is called by `org-babel-execute-src-block'"
    (message "executing SwiftUI source code block")
    (with-temp-buffer
      (insert (ob-swiftui--expand-body body params))
      (shell-command-on-region
       (point-min)
       (point-max)
       "swift -" nil 't)
      (buffer-string)))
#+end_src

The expansion in /ob-swiftui--expand-body/ is a little more interesting. It decorates the block's body, so it can become a fully functional and stand-alone SwiftUI macOS app. If you're familiar with Swift and SwiftUI, the code should be fairly self-explanatory.

From an org babel's perspective, the expanded code is executed whenever we press /C-c C-c/ (or M-x [[https://orgmode.org/manual/The-Very-Busy-C_002dc-C_002dc-Key.html#The-Very-Busy-C_002dc-C_002dc-Key][org-ctrl-c-ctrl-c]]) within the block itself.

It's worthing mentioning that our new implementation supports two babel [[https://www.orgmode.org/worg/org-contrib/babel/header-args.html][header arguments]] (results and view). Both extracted from params using [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/map.el#L106][map-elt]] and replaced in the expanded Swift code to enable/disable snapshotting or explicitly setting a SwiftUI root view.

#+begin_src emacs-lisp
  (defun ob-swiftui--expand-body (body params)
    "Expand BODY according to PARAMS and PROCESSED-PARAMS, return the expanded body."
    (let ((write-to-file (member "file" (map-elt params :result-params)))
          (root-view (when (and (map-elt params :view)
                                (not (string-equal (map-elt params :view) "none")))
                       (map-elt params :view))))
      (format
       "
  // Swift snippet heavily based on Chris Eidhof's code at:
  // https://gist.github.com/chriseidhof/26768f0b63fa3cdf8b46821e099df5ff

  import Cocoa
  import SwiftUI
  import Foundation

  let screenshotURL = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true).appendingPathComponent(ProcessInfo.processInfo.globallyUniqueString + \".png\")
  let preview = %s

  // Body to run.
  %s

  extension NSApplication {
    public func run<V: View>(_ view: V) {
      let appDelegate = AppDelegate(view)
      NSApp.setActivationPolicy(.regular)
      mainMenu = customMenu
      delegate = appDelegate
      run()
    }

    public func run<V: View>(@ViewBuilder view: () -> V) {
      let appDelegate = AppDelegate(view())
      NSApp.setActivationPolicy(.regular)
      mainMenu = customMenu
      delegate = appDelegate
      run()
    }
  }

  extension NSApplication {
    var customMenu: NSMenu {
      let appMenu = NSMenuItem()
      appMenu.submenu = NSMenu()

      let quitItem = NSMenuItem(
        title: \"Quit \(ProcessInfo.processInfo.processName)\",
        action: #selector(NSApplication.terminate(_:)), keyEquivalent: \"q\")
      quitItem.keyEquivalentModifierMask = []
      appMenu.submenu?.addItem(quitItem)

      let mainMenu = NSMenu(title: \"Main Menu\")
      mainMenu.addItem(appMenu)
      return mainMenu
    }
  }

  class AppDelegate<V: View>: NSObject, NSApplicationDelegate, NSWindowDelegate {
    var window = NSWindow(
      contentRect: NSRect(x: 0, y: 0, width: 414 * 0.2, height: 896 * 0.2),
      styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
      backing: .buffered, defer: false)

    var contentView: V

    init(_ contentView: V) {
      self.contentView = contentView
    }

    func applicationDidFinishLaunching(_ notification: Notification) {
      window.delegate = self
      window.center()
      window.contentView = NSHostingView(rootView: contentView)
      window.makeKeyAndOrderFront(nil)

      if preview {
        screenshot(view: window.contentView!, saveTo: screenshotURL)
        // Write path (without newline) so org babel can parse it.
        print(screenshotURL.path, terminator: \"\")
        NSApplication.shared.terminate(self)
        return
      }

      window.title = \"press q to exit\"
      window.setFrameAutosaveName(\"Main Window\")
      NSApp.activate(ignoringOtherApps: true)
    }
  }

  func screenshot(view: NSView, saveTo fileURL: URL) {
    let rep = view.bitmapImageRepForCachingDisplay(in: view.bounds)!
    view.cacheDisplay(in: view.bounds, to: rep)
    let pngData = rep.representation(using: .png, properties: [:])
    try! pngData?.write(to: fileURL)
  }

  // Additional view definitions.
  %s
  "
       (if write-to-file
           "true"
         "false")
       (if root-view
           (format "NSApplication.shared.run(%s())" root-view)
         (format "NSApplication.shared.run {%s}" body))
       (if root-view
           body
         ""))))
#+end_src

For rendering inline SwiftUI previews in Emacs, we rely on NSView's [[https://developer.apple.com/documentation/appkit/nsview/1483440-bitmapimagerepforcachingdisplay][bitmapImageRepForCachingDisplay]] to capture an image snapshot. We write its output to a temporary file and piggyback-ride off org babel's /:results file/ header argument to automatically render the image inline.

Here's ob-swiftui inline rendering in action:

[[file:images/previewing-swiftui-layouts-in-emacs-revisited/obswiftui50.gif]]

When rendering SwiftUI externally, we're effectively running and interacting with the generated macOS app itself.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/previewing-swiftui-layouts-in-emacs-revisited/ob-swiftui-window.gif]]

The two snippets give a general sense of what's needed to enable org babel to handle SwiftUI source blocks. Having said that, the full source and setup instructions are both available on [[https://github.com/xenodium/ob-swiftui][github]].

[[https://github.com/xenodium/ob-swiftui][ob-swiftui]] is now available on [[https://melpa.org/#/ob-swiftui][melpa]].

* [2021-06-19 Sat] Blurring the lines between shell and editor
:PROPERTIES:
:CUSTOM_ID: yasnippet-in-emacs-eshell
:END:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/yasnippet-in-emacs-eshell/yas-eshell.gif]]

I recently [[https://twitter.com/xenodium/status/1404746233860837378][tweeted]] that Vivek Haldar's [[https://blog.vivekhaldar.com/post/3996068979/the-levels-of-emacs-proficiency][10-year old post]] rings true today just the same. He writes about [[https://blog.vivekhaldar.com/post/3996068979/the-levels-of-emacs-proficiency][the levels of Emacs proficiency]]. All 6 levels are insightful in their own right, but for the sake of this post, let's quote an extract from level /4. Shell inside Emacs/:

#+begin_quote
"And then, you learned about it: M-x shell.

It was all just text. Why did you need another application for it? Why should only the shell prompt be editable? Why can’t I move my cursor up a few lines to where the last command spewed out its results? All these problems simply disappear when your shell (or shells) simply becomes another Emacs buffer, upon which all of the text manipulation power of Emacs can be brought to bear."
#+end_quote

In other words, we aren't merely removing shell restrictions, but opening up possibilities...

Take Emacs eshell looping, for example. I use it so infrequently, I could never remember eshell's syntax. I would refer back to EmacsWiki's [[https://www.emacswiki.org/emacs/EshellForLoop][Eshell For Loop]] or Mastering Emacs's [[https://masteringemacs.org/article/complete-guide-mastering-eshell][Mastering Eshell]] comments for a reminder. It finally dawned on me. I don't need to internalize this eshell syntax. I have [[https://github.com/joaotavora/YASnippet][YASnippet]] available like any other buffer. I could just type "for" and let YASnippet do the rest for me.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/yasnippet-in-emacs-eshell/yas-for.gif]]

All I need is a tiny YASnippet:

#+begin_src YASnippet
  #name : Eshell for loop
  #key : for
  # --
  for f in ${1:*} { ${2:echo} "$f"; $3} $0
#+end_src

Want a gentle and succinct YASnippet intro? Check out Jake's [[https://www.reddit.com/r/emacs/comments/o282fq/YASnippet_snippetstemplating_introductiontutorial/][YASnippet introduction video]].

:PROPERTIES:
:CUSTOM_ID: bash-zsh-and-others-welcome
:END:
If you're a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Mode.html][shell-mode]] user, YASnippet would have you covered in your favorite shell. The expansion snippet can be modified to a Bash equivalent, giving us the same benefit. We type "for" and let YASnippet expand and hop over arguments. Here's a Bash equivalent emphasizing the hopping a little more:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/yasnippet-in-emacs-eshell/yasbash.gif]]

#+begin_src YASnippet
  #name : bash for loop
  #key : for
  # --
  for f in ${1:*}; do ${2:echo} $f; done $0
#+end_src

ps. Looks like [[https://github.com/akermu/emacs-libvterm][vterm]], [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html][term]], or [[https://www.emacswiki.org/emacs/AnsiTerm][ansi-term]] work too. See Shane Mulligan's post: [[https://mullikine.github.io/posts/use-yasnippets-in-term/][Use YASnippets in term and vterm in emacs]].

* [2021-06-16 Wed] xcodebuild's SPM support (Xcode 11)
  :PROPERTIES:
  :CUSTOM_ID: xcodebuilds-spm-support-xcode-11
  :END:
Had been a while since I looked into generating Xcode projects from a Swift package. On my latest use of the /generate-xcodeproj/ subcommand, I was greeted by a nice +warning+ surprise...

#+begin_src bash :results output
  swift package generate-xcodeproj
#+end_src

#+RESULTS:
: warning: Xcode can open and build Swift Packages directly. 'generate-xcodeproj' is no longer needed and will be deprecated soon.
: generated: ./FooBar.xcodeproj

Xcode can handle Swift packages directly. Similarly, xcodebuild can handle them too. This isn't new. It's likely been available since Xcode 11. I just totally missed it.

/Note: I've yet to dig into Xcode 13 beta, as Swift packages may already support the build/test features I was after in xcodebuild (like [[https://developer.apple.com/documentation/swift_packages/supportedplatform/3788290-maccatalyst][build/test on Catalyst]])./

In any case, on to xcodebuild... but let's first create a brand new Swift package.

** Creating a Swift package library

#+begin_src bash :results output
  mkdir FooBar && cd FooBar
  swift package init --type library
#+end_src

#+RESULTS:
: Creating library package: FooBar
: Creating Package.swift
: Creating README.md
: Creating .gitignore
: Creating Sources/
: Creating Sources/FooBar/FooBar.swift
: Creating Tests/
: Creating Tests/FooBarTests/
: Creating Tests/FooBarTests/FooBarTests.swift

** List package schemes

We can use xcodebuild to list the available schemes.

#+begin_src bash :results output
  xcodebuild -list
#+end_src

#+RESULTS:
#+begin_example
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -list

User defaults from command line:
    IDEPackageSupportUseBuiltinSCM = YES

Resolve Package Graph

Resolved source packages:
  FooBar: /tmp/FooBar

Information about workspace "FooBar":
    Schemes:
        FooBar

#+end_example

** Show supported platform, architecture, etc

Similarly, we can list destinations supported for the schemes.

#+begin_src bash :results output
  xcodebuild -showdestinations -scheme FooBar
#+end_src

#+RESULTS:
#+begin_example
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showdestinations -scheme FooBar

User defaults from command line:
    IDEPackageSupportUseBuiltinSCM = YES

Resolve Package Graph

Resolved source packages:
  FooBar: /tmp/FooBar



	Available destinations for the "FooBar" scheme:
		{ platform:macOS, arch:x86_64, id:... }
		{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:... }
            ...
		{ platform:iOS Simulator, id:..., OS:14.5, name:iPhone 12 Pro }

	Ineligible destinations for the "FooBar" scheme:
            ...
#+end_example

** macOS builds

Let's build for macOS, though let's first import UIKit into FooBar.swift. This ensures we get an expected failure when building for macOS.

#+begin_src swift
  import UIKit

  struct FooBar {
    var text = "Hello, World!"
  }
#+end_src

Now let's attempt to build it...

#+begin_src bash :results verbatim
  xcodebuild build -quiet -scheme FooBar -destination 'platform=macOS'
#+end_src

#+RESULTS:
#+begin_example
--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:x86_64, id:3D097357-EB7D-565D-9058-CE7C3135927B }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:3D097357-EB7D-565D-9058-CE7C3135927B }
/tmp/FooBar/Sources/FooBar/FooBar.swift:1:8: error: no such module 'UIKit'
import UIKit
       ^
note: Using new build system
note: Building targets in parallel
note: Planning build
note: Analyzing workspace
note: Using build description from disk
note: Build preparation complete
,** BUILD FAILED **

#+end_example

The failure expected as UIKit isn't available on your typical macOS builds.

** macOS Catalyst builds

We do, however, have Catalyst available, so we can use its variant to build for macOS with UIKit support, and.. voilà!

#+begin_src bash :results verbatim
  xcodebuild build -quiet -scheme FooBar -destination 'platform=macOS,variant=Mac Catalyst' && echo \\o/
#+end_src

#+RESULTS:
: \o/

* [2021-06-06 Sun] Emacs org block completion on melpa
:PROPERTIES:
:CUSTOM_ID: emacs-org-block-completion-on-melpa
:END:
When enabled, the character "<" triggers company completion of org blocks.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-org-block-completion-on-melpa/hello-company-org-block.gif]]

I get the occasional ping to package the [[https://xenodium.com/emacs-org-block-company-completion][code from this post]] and publish it [[https://melpa.org/#/company-org-block][on melpa]]. Finally gave it a go. Moved the code [[https://github.com/xenodium/company-org-block][here]].

This was my first time publishing on melpa. The process was very [[https://github.com/melpa/melpa/pull/7593][smooth]]. Big thanks to melpa volunteers!

* [2021-06-01 Tue] Emacs DWIM: do what ✨I✨ mean
:PROPERTIES:
:CUSTOM_ID: emacs-dwim-do-what-i-mean
:END:
Update: There's a DWIM [[https://xenodium.com/emacs-dwim-swiper-vs-isearch-vs-phi-search/][follow-up for searching]].

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-dwim-do-what-i-mean/do-what-i-mean.gif]]

I was a rather puzzled the first time I spotted DWIM in an Emacs interactive command name. Don't think I remember what the command itself was, but what's important here is that [[https://en.wikipedia.org/wiki/DWIM][DWIM]] stands for [[https://en.wikipedia.org/wiki/DWIM][do what I mean]].

I love DWIM interactive commands. They enable commands to be smarter and thus pack more functionality, without incurring the typical cognitive overhead associated with remembering multiple commands (or key bindings). The Emacs manual does a great job describing DWIM for the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Comment-Commands.html][comment-dwim]] command:

#+begin_src
 The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.
#+end_src

It's really great to find built-in DWIM-powered Emacs commands. Third-party packages often include them too. I typically gravitate towards these commands and bind them in my Emacs config. Examples being upcase-dwim, downcase-dwim, or mc/mark-all-dwim.

But what if the DWIM command doesn't exist or the author has written a command for what /they/ mean? This is your editor, so you can make it do what /you/ mean.

Take for example, [[https://orgmode.org/manual/Handling-Links.html][org-insert-link]], bound to /C-c C-l/ by default. It's handy for inserting [[https://orgmode.org/guide/Hyperlinks.html][org mode links]]. I used it so frequently that I quickly internalized its key binding. Having said that, I often found myself doing some lightweight preprocessing prior to invoking /org-insert-link/. What if I can /make org-insert-link do what I mean/?

** What do I mean?

*** Use URLs when in clipboard

If the URL is already in the clipboard, don't ask me for it. Just use it.

*** Use the region too

If I have a region selected and there's a URL in the clipboard, just sort it out without user interaction.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-dwim-do-what-i-mean/link-this-text.gif]]


*** Automatically fetch titles

Automatically fetch URL titles from their HTML tag, but ask me for tweaks before insertion.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-dwim-do-what-i-mean/do-what-i-mean.gif]]

*** Fallback to org-insert-link

If my DWIM rules don't apply, fall back to using good ol' [[https://orgmode.org/manual/Handling-Links.html][org-insert-link]].

My most common use case here is when editing an existing link where I don't want neither its title nor URL automatically handled.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-dwim-do-what-i-mean/edit-link.gif]]

** The code

This is your own DWIM command that does what /you/ mean. Strive to write a clean implementation, but hey you can be forgiven for not handling all the cases that other folks /may/ want or inlining more code than usual. The goal is to bend your editor a little, not write an Emacs package.

#+begin_src emacs-lisp
  (defun ar/org-insert-link-dwim ()
    "Like `org-insert-link' but with personal dwim preferences."
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
             (delete-region (region-beginning) (region-end))
             (insert (org-make-link-string clipboard-url region-content)))
            ((and clipboard-url (not point-in-link))
             (insert (org-make-link-string
                      clipboard-url
                      (read-string "title: "
                                   (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                     (dom-text (car
                                                (dom-by-tag (libxml-parse-html-region
                                                             (point-min)
                                                             (point-max))
                                                            'title))))))))
            (t
             (call-interactively 'org-insert-link)))))
#+end_src

** Org web tools package

I showed how to write your own DWIM command, so you can make Emacs do what ✨you✨ mean. /ar/org-insert-link-dwim/ was built for my particular needs.

Having said all of this, alphapapa has built a great package with helpers for the org web/link space. It doesn't do what I mean (for now anyway), but it may work for you: [[https://github.com/alphapapa/org-web-tools][org-web-tools: View, capture, and archive Web pages in Org-mode]][fn:1].

[fn:1] This link was brought to you by /ar/org-insert-link-dwim/.

* [2021-05-28 Fri] Emacs link scraping (2021 edition)
  :PROPERTIES:
  :CUSTOM_ID: emacs-link-scraping-2021-edition
  :END:
#+ATTR_HTML: :width 95% :height 95%
[[file:images/emacs-link-scraping-2021-edition/scrape.png]]

A recent Hacker News post, [[https://news.ycombinator.com/item?id=27302195][Ask HN: Favorite Blogs by Individuals]], led me to dust off my oldie but trusty [[https://github.com/xenodium/dotsies/blob/92ef8259f016cdd4f67caf0e520096f6da4f7a18/emacs/ar/ar-url.el#L42][command to extract comment links]]. I use it to dissect these wonderful references more effectively.

You see, I wrote this command [[https://xenodium.com/get-emacs-to-gather-links-in-posts/][back in 2015]]. We can likely revisit and improve. The [[https://github.com/zweifisch/enlive][enlive]] package continues to do a fine job [[https://github.com/zweifisch/enlive/blob/604a8ca272b6889f114e2b5a13adb5b1dc4bae86/enlive.el#L39][fetching]], parsing, and [[https://github.com/zweifisch/enlive/blob/604a8ca272b6889f114e2b5a13adb5b1dc4bae86/enlive.el#L142][querying]] HTML. Let's improve my code instead... we can shed a few redundant bits and maybe use [[https://xenodium.com/modern-elisp-libraries/][newer libraries and features]].

Most importantly, let's improve the user experience by sanitizing and filtering URLs a little better.

We start by writing a function that looks for a URL in the clipboard and subsequently fetches, parses, and extracts all links found in the target page.

#+begin_src emacs-lisp
  (require 'enlive)
  (require 'seq)

  (defun ar/scrape-links-from-clipboard-url ()
    "Scrape links from clipboard URL and return as a list. Fails if no URL in clipboard."
    (unless (string-prefix-p "http" (current-kill 0))
      (user-error "no URL in clipboard"))
    (thread-last (enlive-query-all (enlive-fetch (current-kill 0)) [a])
      (mapcar (lambda (element)
                (string-remove-suffix "/" (enlive-attr element 'href))))
      (seq-filter (lambda (link)
                    (string-prefix-p "http" link)))
      (seq-uniq)
      (seq-sort (lambda (l1 l2)
                  (string-lessp (replace-regexp-in-string "^http\\(s\\)*://" "" l1)
                                (replace-regexp-in-string "^http\\(s\\)*://" "" l2))))))
#+end_src

Let's chat /(current-kill 0)/ for a sec. No improvement from my previous usage, but let's just say building interactive commands that work with your current clipboard (or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Kill-Ring.html][kill ring]] in Emacs terminology) is super handy (see [[https://xenodium.com/emacs-clone-git-repo-from-clipboard/][clone git repo from clipboard]]).

Moving on to sanitizing and filtering URLs... Links often have trailing slashes. Let's flush them. [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/subr-x.el#L261][string-remove-suffix]] to the rescue. This and other handy string-manipulating functions are built into Emacs since 24.4 as part of [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/subr-x.el][subr-x.el]].

Next, we can keep http(s) links and ditch everything else. The end-goal is to extract links posted by users, so these are typically fully qualified external URLs. [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/seq.el][seq-filter]] steps up to the task, included in Emacs since 25.1 as part of the [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/seq.el][seq.el family]]. We remove duplicate links using [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/seq.el#L431][seq-uniq]] and sort them via [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/seq.el#L255][seq-sort]]. All part of the same package.

When sorting, we could straight up use /seq-sort/ and /string-lessp/ and nothing else, but it would separate http and https links. Let's not do that, so we drop /http(s)/ prior to comparing strings in /seq-sort/'s predicate. [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/subr.el#L4468][replace-regexp-in-string]] does the job here, but if you'd like to skip regular expressions, [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/subr-x.el#L255][string-remove-prefix]] works just as well.

Yay, sorting no longer cares about http vs https:

#+begin_src
  https://andymatuschak.org
  http://antirez.com
  https://apenwarr.ca/log
  ...
#+end_src

With all that in mind, let's flatten list processing using [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/subr-x.el#L69][thread-last]]. This isn't strictly necessary, but since this is the 2021 edition, we'll throw in this macro added to Emacs in 2016 as part of 25.1. Arthur Malabarba has a [[https://endlessparentheses.com/new-in-emacs-25-1-more-flow-control-macros.html][great post on thread-last]].

Now that we've built out /ar/scrape-links-from-clipboard-url/ function, let's make its content consumable!

** The completing frameworks way
This is the 2021 edition, so power up your completion framework du jour and feed the output of /ar/scrape-links-from-clipboard-url/ to our completion robots...

#+ATTR_HTML: :width 95% :height 95%
[[file:images/emacs-link-scraping-2021-edition/scrape_complete.gif]]

I'm heavily vested in [[https://github.com/abo-abo/swiper][ivy]], but since we're using the built-in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][completing-read]] function, any completion framework like [[https://github.com/minad/vertico][vertico]], [[https://github.com/raxod502/selectrum/][selectrum]], [[https://github.com/emacs-helm/helm][helm]], or [[https://www.gnu.org/software/emacs/manual/html_node/ido/index.html][ido]] should kick right in to give you extra powers.

#+begin_src emacs-lisp
  (defun ar/view-completing-links-at-clipboard-url ()
    "Scrape links from clipboard URL and open all in external browser."
    (interactive)
    (browse-url (completing-read "links: "
                                 (ar/scrape-links-from-clipboard-url))))
#+end_src

** The auto-open way (use with caution)

Sometimes you just want to open every link posted in the comments and use your browser to discard, closing tabs as needed. The recent HN news instance wasn't one of these cases, with a whopping 398 links returned by our /ar/scrape-links-from-clipboard-url/.

#+ATTR_HTML: :width 95% :height 95%
[[file:images/emacs-link-scraping-2021-edition/scrape_browse.gif]]

/Note: I capped the results to 5 in this gif/demo to prevent a Firefox tragedy (see [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/emacs-lisp/seq.el#L231][seq-take]])./

In a case like Hacker News's, we don't want to surprise-attack the user and bomb their browser by opening a gazillion tabs, so let's give a little heads-up using [[https://github.com/emacs-mirror/emacs/blob/3af9e84ff59811734dcbb5d55e04e1fdb7051e77/lisp/subr.el#L2869][y-or-n-p]].

#+begin_src emacs-lisp
  (defun ar/browse-links-at-clipboard-url ()
    (interactive)
    (let ((links (ar/scrape-links-from-clipboard-url)))
      (when (y-or-n-p (format "Open all %d links? " (length links)))
        (mapc (lambda (link)
                (browse-url link))
              links))))
#+end_src

** The org way

My [[https://xenodium.com/get-emacs-to-gather-links-in-posts/][2015 solution]] leveraged an [[https://orgmode.org/][org mode]] buffer to dump the fetched links. The org way is still my favorite. You can use whatever existing Emacs super powers you already have on top of the org buffer, including searching and filtering fueled by your favourite completion framework. I'm a fan of [[https://oremacs.com/][Oleh]]'s [[https://github.com/abo-abo/swiper][swiper]].

#+ATTR_HTML: :width 95% :height 95%
[[file:images/emacs-link-scraping-2021-edition/scrape_org.gif]]

The 2021 implementation is mostly a tidy-up, removing some cruft, but also uses our new /ar/scrape-links-from-clipboard-url/ function to filter and sort accordingly.

#+begin_src emacs-lisp
  (require 'org)

  (defun ar/view-links-at-clipboard-url ()
    "Scrape links from clipboard URL and dump to an org buffer."
    (interactive)
    (with-current-buffer (get-buffer-create "*links*")
      (org-mode)
      (erase-buffer)
      (mapc (lambda (link)
              (insert (org-make-link-string link) "\n"))
            (ar/scrape-links-from-clipboard-url))
      (goto-char (point-min))
      (switch-to-buffer (current-buffer))))
#+end_src

** Emacs + community + packages + your own glue = awesome

To power our 2021 link scraper, we've used newer libraries included in more recent versions of Emacs, leveraged an older but solid HTML-parsing package, pulled in org mode (the epicenter of Emacs note-taking), dragged in our favorite completion framework, and tickled our handy browser all by smothering the lot with some elisp glue to make Emacs do exactly what we want. [[http://emacsrocks.com/][Emacs does rock]].

* [2021-05-23 Sun] OCR bookmarks
:PROPERTIES:
:CUSTOM_ID: ocr-bookmarks
:END:
- [[https://github.com/schappim/macOCR][schappim/macOCR: Get any text on your screen into your clipboard.]].
* [2021-05-19 Wed] gpg: decryption failed: No secret key (macOS)
:PROPERTIES:
:CUSTOM_ID: gpg-decryption-failed-no-secret-key-macos
:END:
#+begin_src
  gpg: decryption failed: No secret key
#+end_src

OMG! Where's my secret key gone!?

But but but, /gpg --list-secret-keys/ says they're there. Puzzled...

Ray Oei's Stack Overflow [[https://stackoverflow.com/a/66234166][answer]] solved the mystery for me: pinentry never got invoked, so likely something's up with the agent... Killing (and thus restaring) the gpg-agent did the trick:

#+begin_src sh
  gpgconf --kill gpg-agent
#+end_src

Thank you internet stranger. Balance restored.

* [2021-05-17 Mon] Emacs plus --with-native-comp
:PROPERTIES:
:CUSTOM_ID: emacs-plus-with-native-comp
:END:
#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-plus-with-native-comp/brew-native-comp.png]]

I'm a big fan of [[https://d12frosted.io/][Boris Buliga]]'s [[https://github.com/d12frosted/homebrew-emacs-plus][Emacs Plus]] [[https://brew.sh/][homebrew]] recipe for customizing and installing Emacs builds on macOS.

For a little while, I took a detour and built Emacs myself, so I could enable [[https://twitter.com/Koral_001][Andrea Corallo]]'s fantastic [[http://akrl.sdf.org/gccemacs.html][native compilation]]. I documented the steps [[https://xenodium.com/trying-out-gccemacs-on-macos/][here]]. Though it was fairly straightforward, I did miss Emacs Plus's convenience.

I had been meaning to check back on Emacs Plus for native compilation support. Turns out, it was merged back in [[https://github.com/d12frosted/homebrew-emacs-plus/pull/188][Dec 2020]], and it works great!

Enabling native compilation is simple (just use /--with-native-comp/). As a bonus, you get all the Emacs Plus goodies. I'm loving /--with-elrumo2-icon/, enabling a spiffy icon to go with macOS Big Sur. /--with-no-frame-refocus/ is also handy to [[https://xenodium.com/no-emacs-frame-refocus-on-macos/][avoid refocusing other frames]] when another one is closed.

In any case, here's the minimum needed to install Emacs Plus with native compilation support enabled:

#+begin_src sh
  brew tap d12frosted/emacs-plus
  brew install emacs-plus@28 --with-native-comp
#+end_src

Sit tight. Homebrew will build and install some chunky dependencies (including gcc and libgccjit).

Note: Your init.el needs tweaking to take advantage of native compilation. See my [[https://xenodium.com/trying-out-gccemacs-on-macos/][previous post]] for how I set mine, or go straight to [[https://github.com/xenodium/dotsies/blob/main/emacs/features/fe-package-extensions.el#L19][my config]].

* [2021-05-02 Sun] Cycling window layouts with hammerspoon
  :PROPERTIES:
  :CUSTOM_ID: cycling-window-layouts-via-hammerspoon
  :END:
Back in January, Patrik Collison [[https://twitter.com/patrickc/status/1351650517869465601][tweeted]] about [[https://rectangleapp.com/][Rectangle]]'s [[https://github.com/rxhanson/Rectangle/wiki/Todo-Mode][Todo mode]]. Rectangle looks great. Although I've not yet adopted it, Todo mode really resonates with me. I've been achieving similar functionality with [[https://www.hammerspoon.org/][hammerspoon]].

#+ATTR_HTML: :width 75% :height 75%
[[file:images/cycling-window-layouts-via-hammerspoon/cycle.gif]]

Here's a quick and dirty function to cycle through my window layouts:

#+begin_src python
  function reframeFocusedWindow()
     local win = hs.window.focusedWindow()
     local maximizedFrame = win:screen():frame()
     maximizedFrame.x = maximizedFrame.x + 15
     maximizedFrame.y = maximizedFrame.y + 15
     maximizedFrame.w = maximizedFrame.w - 30
     maximizedFrame.h = maximizedFrame.h - 30

     local leftFrame = win:screen():frame()
     leftFrame.x = leftFrame.x + 15
     leftFrame.y = leftFrame.y + 15
     leftFrame.w = leftFrame.w - 250
     leftFrame.h = leftFrame.h - 30

     local rightFrame = win:screen():frame()
     rightFrame.x = rightFrame.w - 250 + 15
     rightFrame.y = rightFrame.y + 15
     rightFrame.w = 250 - 15 - 15
     rightFrame.h = rightFrame.h - 30

     -- Make space on right
     if win:frame() == maximizedFrame then
       win:setFrame(leftFrame)
       return
     end

     -- Make space on left
     if win:frame() == leftFrame then
       win:setFrame(rightFrame)
       return
     end

     win:setFrame(maximizedFrame)
  end
#+end_src

A here's my *⌥-F* binding to *reframeFocusedWindow*:

#+begin_src python
  hs.hotkey.bind({"alt"}, "F", reframeFocusedWindow)
#+end_src
* [2021-04-10 Sat] Flat Habits meets org agenda
:PROPERTIES:
:CUSTOM_ID: flat-habits-meets-org-agenda
:END:
UPDATE: Flat Habits now has its own page at [[https://flathabits.com/][flathabits.com]].

Flat Habits v1.0.2 is [[https://apps.apple.com/app/id1558358855][out today]], with habit-toggling now supported from the streak view.

Flat Habits runs on org, making it a great complement to Emacs and org agenda \o/

#+ATTR_HTML: :width 75% :height 75%
[[file:images/flat-habits-meets-org-agenda/flat_agenda.gif]]

#+BEGIN_EXPORT html
<div style="text-align: center;">
  <a href="https://apps.apple.com/app/id1558358855">
    <img src="../images/flat-habits-for-ios/download-on-app-store.png" alt="today_no_filter.png" height="40px">
  </a>
</div>
#+END_EXPORT

* [2021-03-23 Tue] Flat Habits v1.0.1 (org import menu)
:PROPERTIES:
:CUSTOM_ID: flat-habits-v101-org-import-menu
:END:
UPDATE: Flat Habits now has its own page at [[https://flathabits.com/][flathabits.com]].

Flat Habits v1.0.1 is now released and [[https://apps.apple.com/app/id1558358855][available]] in the App Store.

** org import (import vs in-place)

We can now import org files from the menu. Importing gives ya the option to either import (copy into the app) or open in-place. The latter enables users to sync org files with other iOS apps or just open/edit from Emacs for the full org-mode/agenda experience.

#+BEGIN_EXPORT html
<div style="text-align: center;">
  <img src="../images/flat-habits-v101-org-import-menu/menu.png" alt="today_no_filter.png" width="300px" style="padding: 10px;">
  <img src="../images/flat-habits-v101-org-import-menu/filebrowse.png" alt="today_no_filter.png" width="300px" style="padding: 10px;">
</div>
#+END_EXPORT

Syncing with your desktop can be achieved by either iCloud or by enabling other providers in the Files app (after installing the likes of Google Drive, Dropbox, etc).

/Please note that importing (copying into the app) is currently the recommended flow./ Opening in-place and syncing is still fairly experimental, so please back up your org files regularly. If you do run into syncing issues, please get in touch.

Good luck with your habits!

* [2021-03-17 Wed] Flat Habits for iOS (powered by org)
:PROPERTIES:
:CUSTOM_ID: flat-habits-for-ios
:END:
UPDATE: Flat Habits now has its own page at [[https://flathabits.com/][flathabits.com]].

/No friction. No social. No analytics. No account. No cloud. No lock-in./

** So what is it?

An iOS app to help you form and track lasting habits.

#+BEGIN_EXPORT html
<div style="text-align: center;">
  <img src="../images/flat-habits-for-ios/today_no_filter.png" alt="today_no_filter.png" width="300px" style="padding: 10px;">
  <img src="../images/flat-habits-for-ios/meditate.png" alt="today_no_filter.png" width="300px" style="padding: 10px;">
  <a href="https://apps.apple.com/app/id1558358855">
    <img src="../images/flat-habits-for-ios/download-on-app-store.png" alt="today_no_filter.png" height="40px">
  </a>
</div>
#+END_EXPORT

** Why an app?

Tracking and accountability may help you develop positive habits. A simple habit-tracking app should make this easy. I'm not a habits expert, but got inspired by James Clear's [[https://jamesclear.com/atomic-habits][Atomic Habits]]. Read that book if you're interested in the topic.

I wanted a frictionless habit tracker that gets out of the way, so I built one to my taste.

** Sounds like a lot of work?

You mean habit tracking? It's not. I tried to make the app simple and focused. Mark a habit done whenever you do it. It's really encouraging to see your daily streaks grow. I really don't want to break them.

** What kind of habits?

Any recurring habit you'd like to form like exercise, water the plants, read, make your bed, recycle, call grandma, yoga, cleaning, drink water, meditate, take a nap, make your lunch, journal, laundry, push-ups, sort out the dryer filter, floz, take your vitamins, take your meds, eat salad, eat fruit, practice a language, practice an instrument, go to bed early...

** So it's like a task/todo app?

Nope. This app focuses solely on habits. Unlike todos/tasks, habits must happen regularly. If you don't water the plants, they will die. If you don't exercise regularly, you won't get the health benefits. Keep your habits separate from that long list of todos. You know, that panic-inducing list you're too afraid to look at.

** Where is my data stored?

On your iPhone as a plain text file (in [[https://orgmode.org/][org mode]] format). You can view, edit, or migrate your data at any time (use export from the menu). You may also save it to a shared location, so you can access it from multiple devices/apps. Some of us like to [[http://xenodium.com/frictionless-org-habits-on-ios/][use our beloved text editors]] (Emacs, Vim, VSCode, etc.) to poke at [[https://orgmode.org/manual/Tracking-your-habits.html][habits]].

** Got more questions?

I may not have the answer, but I can try. Ping me at /flathabits*at*xenodium.com/.

** Privacy policy
No personal data is sent to any server, as there is no server component to this app. There are neither third party integrations, accounts, analytics, nor trackers in this app. All your data is kept on your iPhone, unless you choose a cloud provider to sync or store your data. See your cloud provider's privacy policy for details on how they may handle it.

If you choose to send feedback by email, you have the option to review and attach logs to help diagnose issues. If you'd like an email thread to be deleted, just ask.

To join TestFlight as a beta tester, you likely gave your email address. If you'd like your email removed, just ask. Note that TestFlight has its own [[https://www.apple.com/legal/internet-services/itunes/testflight/sren/terms.html][Terms Of Service]].

* [2021-02-21 Sun] Frictionless org habits on iOS
  :PROPERTIES:
  :CUSTOM_ID: frictionless-org-habits-on-ios
  :END:
UPDATE: Flat Habits now has its own page at [[https://flathabits.com/][flathabits.com]].

#+ATTR_HTML: :width 80% :height 80%
[[file:images/frictionless-org-habits-on-ios/flat_habits.gif]]

I've been wanting org to keep track of my daily habits for a little while. The catalyst: reading James Clear's wonderful [[https://jamesclear.com/atomic-habits][Atomic Habits]] (along with plenty of lock-down inspiration).

As much as I live in Emacs and org mode, it just wasn't practical enough to rely on my laptop for tracking habits. I wanted less friction, so I've been experimenting with building a toy app for my needs. Naturally, org support was a strict requirement, so I could always poke at it from my beloved editor.

I've been using the app every day with success. The habits seem to be sticking, but equally important, it's been really fun to join the fabulous world of Emacs/Org with iOS/SwiftUI.

This is all very experimental[fn:1] and as mentioned on [[https://www.reddit.com/r/emacs/comments/ljurwx/org_habits_ios_app_want_to_try_it/][reddit]] (follow-up [[https://www.reddit.com/r/emacs/comments/lp62vn/org_habits_ios_app_followup_twoway_edit/][here]]) and [[https://twitter.com/xenodium/status/1361034010047176705][twitter]], the app isn't available on the App Store. I may consider publishing if there's enough interest, but in the mean time, you can reach out and install via [[https://testflight.apple.com/][TestFlight]].

Send me an email address to /flathabits*at*xenodium.com/ for a TestFlight invite.

[fn:1] The app's been fairly stable, but who knows... please backup your org file before feeding it to the lion.

** 2021-03-12 Update: Now with iOS Files app/sync integration

If you can sync your org file with your iPhone (ie. Drive/Dropbox/iCloud), and list it in the Files app, you should be able to open/edit[fn:1] with /Flat Habits/ (that's the name now). With iOS Files integration, you should be able to sync your habits between your iPhone and your [[https://www.gnu.org/software/emacs/][funky editor]] powering org mode[fn:2].

#+ATTR_HTML: :width 40%
[[file:images/frictionless-org-habits-on-ios/filesapp_shorter.gif]]

[fn:2] Yes, this post was written in [[https://orgmode.org/][org mode]].

* [2021-02-20 Sat] Symbolicating iOS crashes
  :PROPERTIES:
  :CUSTOM_ID: symbolicating-ios-crashes
  :END:
#+begin_src sh
  export DEVELOPER_DIR=$(xcode-select --print-path)
  /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash crashlog.crash MyFoo.app.dSYM
#+end_src
* [2021-01-23 Sat] Emacs: mu4e icons
:PROPERTIES:
:CUSTOM_ID: mu4e-icons
:END:
Recently spotted [[https://github.com/stardiviner/mu4e-marker-icons][mu4e-marker-icons]], which adds mu4e icons using [[https://github.com/domtronn/all-the-icons.el][all-the-icons]].

Although I'm not currently using all-the-icons, it did remind me to take a look at mu4e's built-in variables to spiff up my email. It's pretty simple. Find the icons you like and set them as follows:

#+ATTR_HTML: :width 50% :height 50%
[[file:images/mu4e-icons/mu4eicons.png]]

#+begin_src emacs-lisp
  (setq mu4e-headers-unread-mark    '("u" . "📩 "))
  (setq mu4e-headers-draft-mark     '("D" . "🚧 "))
  (setq mu4e-headers-flagged-mark   '("F" . "🚩 "))
  (setq mu4e-headers-new-mark       '("N" . "✨ "))
  (setq mu4e-headers-passed-mark    '("P" . "↪ "))
  (setq mu4e-headers-replied-mark   '("R" . "↩ "))
  (setq mu4e-headers-seen-mark      '("S" . " "))
  (setq mu4e-headers-trashed-mark   '("T" . "🗑️"))
  (setq mu4e-headers-attach-mark    '("a" . "📎 "))
  (setq mu4e-headers-encrypted-mark '("x" . "🔑 "))
  (setq mu4e-headers-signed-mark    '("s" . "🖊 "))
#+end_src

* [2021-01-02 Sat] Luxembourg travel bookmarks
  :PROPERTIES:
  :CUSTOM_ID: luxembourg-travel-bookmarks
  :END:
- [[https://www.mullerthal-trail.lu/en][Hiking in Luxembourg - Mullerthal Trail]].

* [2021-01-02 Sat] South Africa travel bookmarks
  :PROPERTIES:
  :CUSTOM_ID: south-africa-travel-bookmarks
  :END:
- [[https://www.tripsavvy.com/blyde-river-canyon-south-africa-guide-4157668][Blyde River Canyon, South Africa: The Complete Guide]].

* [2020-12-29 Tue] Swift package code coverage (plus Emacs overlay)
  :PROPERTIES:
  :CUSTOM_ID: swift-package-code-coverage
  :END:
While playing around with Swift package manager, I had a quick look into code coverage options. Luckily, coverage reporting and exporting are supported out of the box (via [[https://llvm.org/docs/CommandGuide/llvm-cov.html][llvm-cov]]).

Ensure tests are invoked as follows:

#+begin_src sh
  swift test --enable-code-coverage
#+end_src

A high level report can be generated with:

#+begin_src bash :results verbatim
  xcrun llvm-cov report .build/x86_64-apple-macosx/debug/FooPackageTests.xctest/Contents/MacOS/FooPackageTests \
        -instr-profile=.build/x86_64-apple-macosx/debug/codecov/default.profdata -ignore-filename-regex=".build|Tests"
#+end_src

#+RESULTS:
: Filename                                   Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover
: --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
: /tmp/Foo/Sources/Foo/Foo.swift                   2                 1    50.00%           2                 1    50.00%           6                 3    50.00%
: --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
: TOTAL                                            2                 1    50.00%           2                 1    50.00%           6                 3    50.00%

llvm-cov can export as lcov format:

#+begin_src sh
  xcrun llvm-cov export -format="lcov" .build/x86_64-apple-macosx/debug/FooPackageTests.xctest/Contents/MacOS/FooPackageTests -instr-profile=.build/x86_64-apple-macosx/debug/codecov/default.profdata -ignore-filename-regex=".build|Tests" > coverage.lcov
#+end_src

With the report in lcov format, we can look for an Emacs package to visualize coverage in source files. Found [[https://github.com/twada/coverlay.el][coverlay.el]] to require minimal setup. I was interested in highlighting only untested areas, so I set /tested-line-background-color/
 to nil:

#+begin_src emacs-lisp
  (use-package coverlay
    :ensure t
    :config
    (setq coverlay:tested-line-background-color nil))
#+end_src

After installing coverlay, I enabled the minor mode via /M-x coverlay-minor-mode/, invoked /M-x coverlay-watch-file/ to watch /coverage.lcov/ for changes, and voilà!

[[file:images/swift-package-code-coverage/coverage.png]]

* [2020-12-29 Tue] Hiking bookmarks
  :PROPERTIES:
  :CUSTOM_ID: hiking-bookmarks
  :END:
- [[https://news.ycombinator.com/item?id=25568856][A growing list of long distance hikes around the world (Hacker News)]].

* [2020-12-28 Mon] Patience
  :PROPERTIES:
  :CUSTOM_ID: patience
  :END:
Via [[https://twitter.com/orangebook_/status/1291844997097099265?s=12][Orange Book]], a reminder to myself:

- In investing, patience is rewarded.
- In growing a talent, patience is rewarded.
- In building a business, patience is rewarded.
- In love and friendships, patience is rewarded.
- Patience = success

I feel like there's an Emacs lesson somewhere in there...

* [2020-12-26 Sat] Chess bookmarks
  :PROPERTIES:
  :CUSTOM_ID: chess-bookmarks
  :END:
  - [[https://dwheeler.com/chess-openings/][A Beginner's Garden of Chess Openings]].
  - [[https://news.ycombinator.com/item?id=25446399][A Beginner's Garden of Chess Openings (2002) (Hacker News)]].

* [2020-12-20 Sun] 40 Coolest neighbourhoods in the world
:PROPERTIES:
:CUSTOM_ID: 40-coolest-neighborhoods-in-the-world
:END:
Via TimeOut's [[https://www.timeout.com/coolest-neighbourhoods-in-the-world][40 Coolest Neighbourhoods in the World Right Now]]:

1. Esquerra de l’Eixample, Barcelona
2. Downtown, Los Angeles
3. Sham Shui Po, Hong Kong
4. Bedford-Stuyvesant, New York
5. Yarraville, Melbourne
6. Wedding, Berlin
7. Shaanxi Bei Lu/Kangding Lu, Shanghai
8. Dennistoun, Glasgow
9. Haut-Marais, Paris
10. Marrickville, Sydney
11. Verdun, Montreal
12. Kalamaja, Tallinn
13. Hannam-dong, Seoul
14. Bonfim, Porto
15. Ghosttown, Oakland
16. Chula-Samyan, Bangkok
17. Alvalade, Lisbon
18. Noord, Amsterdam
19. Centro, São Paulo
20. Holešovice, Prague
21. Lavapiés, Madrid
22. Opebi, Lagos
23. Narvarte, Mexico City
24. Uptown, Chicago
25. Little Five Points, Atlanta
26. Wynwood, Miami
27. Phibsboro, Dublin
28. Nørrebro, Copenhagen
29. Bugis, Singapore
30. Gongguan, Taipei
31. Soho, London
32. Binh Thanh, Ho Chi Minh City
33. Melville, Johannesburg
34. Kabutocho, Tokyo
35. Porta Venezia, Milan
36. Taman Paramount, Kuala Lumpur
37. Allston, Boston
38. Bandra West, Mumbai
39. Arnavutköy, Istanbul
40. Banjar Nagi, Ubud

* [2020-12-05 Sat] Emacs: Rotate my macOS display
  :PROPERTIES:
  :CUSTOM_ID: emacs-rotate-my-macos-display
  :END:
Every so often, I rotate my monitor (vertical vs horizontal) for either work or to watch a movie. macOS enables changing the display rotation via a dropdown menu (under /Preferences > Displays > Rotation/) where you can pick between /Standard/, /90°/, /180°/, and /270°/. That's all fine, but what I'd really like is a quick way to toggle between my preferred two choices: /Standard/ and /270°/.

Unsurprisingly, I'd also like to invoke it as an interactive command via Emacs's /M-x/ (see [[http://xenodium.com/emacs-connect-my-bluetooth-speaker/index.html][Emacs: connect my Bluetooth speaker]]). With narrowing frameworks like [[https://github.com/abo-abo/swiper][ivy]], [[https://emacs-helm.github.io/helm/][helm]], and [[https://www.gnu.org/software/emacs/manual/html_mono/ido.html][ido]], invoking these commands is just a breeze.

Turns out, this was pretty simple to accomplish, thanks to Eric Nitardy's [[https://github.com/CdLbB/fb-rotate][fb-rotate]] command line utility. All that's left to do is wrap it in a tiny elisp +function+ hack, add the toggling logic, and voilà!

#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-rotate-my-macos-display/rotate.gif]]

/The screen capture goes a little funky when rotating the display, but you get the idea. It works better in person :)/

...and here's the snippet:

#+begin_src emacs-lisp
  (defun ar/display-toggle-rotation ()
    (interactive)
    (require 'cl-lib)
    (cl-assert (executable-find "fb-rotate") nil
               "Install fb-rotate from https://github.com/CdLbB/fb-rotate")
    ;; #  Display_ID    Resolution  ____Display_Bounds____  Rotation
    ;; 2  0x2b347692    1440x2560      0     0  1440  2560    270    [main]
    ;; From fb-rotate output, get the `current-rotation' from Column 7, row 1 zero-based.
    (let ((current-rotation (nth 7 (split-string (nth 1 (process-lines "fb-rotate" "-i"))))))
      (call-process-shell-command (format "fb-rotate -d 1 -r %s"
                                          (if (equal current-rotation "270")
                                              "0"
                                            "270")))))
#+end_src
* [2020-11-29 Sun] Emacs: Clone git repo from clipboard
  :PROPERTIES:
  :CUSTOM_ID: emacs-clone-git-repo-from-clipboard
  :END:
Cloning git repositories is a pretty common task. For me, it typically goes something like:

- Copy git repo URL from browser.
- Drop to Emacs eshell.
- Change current directory.
- Type "git clone ".
- Paste git repo URL.
- Run git command.
- Change directory to cloned repo.
- Open dired.

No biggie, but why go through the same steps every time? We can do better. We have a hyper malleable editor, so let's get it to grab the URL from clipboard and do its thing.

/shell-command/ or /async-shell-command/ can help in this space, but require additional work: change location, re-type command, what if directory already exists... This is Emacs, so we can craft the exact experience we want. I did take inspiration from /shell-command/ to display the process buffer correctly (git progress, control codes, etc.) and landed on the following experience:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-clone-git-repo-from-clipboard/git_clone_dired.gif]]

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-

  (defun ar/git-clone-clipboard-url ()
    "Clone git URL in clipboard asynchronously and open in dired when finished."
    (interactive)
    (cl-assert (string-match-p "^\\(http\\|https\\|ssh\\)://" (current-kill 0)) nil "No URL in clipboard")
    (let* ((url (current-kill 0))
           (download-dir (expand-file-name "~/Downloads/"))
           (project-dir (concat (file-name-as-directory download-dir)
                                (file-name-base url)))
           (default-directory download-dir)
           (command (format "git clone %s" url))
           (buffer (generate-new-buffer (format "*%s*" command)))
           (proc))
      (when (file-exists-p project-dir)
        (if (y-or-n-p (format "%s exists. delete?" (file-name-base url)))
            (delete-directory project-dir t)
          (user-error "Bailed")))
      (switch-to-buffer buffer)
      (setq proc (start-process-shell-command (nth 0 (split-string command)) buffer command))
      (with-current-buffer buffer
        (setq default-directory download-dir)
        (shell-command-save-pos-or-erase)
        (require 'shell)
        (shell-mode)
        (view-mode +1))
      (set-process-sentinel proc (lambda (process state)
                                   (let ((output (with-current-buffer (process-buffer process)
                                                   (buffer-string))))
                                     (kill-buffer (process-buffer process))
                                     (if (= (process-exit-status process) 0)
                                         (progn
                                           (message "finished: %s" command)
                                           (dired project-dir))
                                       (user-error (format "%s\n%s" command output))))))
      (set-process-filter proc #'comint-output-filter)))
#+end_src

Comment on [[https://www.reddit.com/r/emacs/comments/k3iter/simplequick_git_repo_clone_from_browser_to_emacs/][reddit]] or [[https://twitter.com/xenodium/status/1333111043791458309][twitter]].

** Updates
- Added lexical binding.
- Checks clipboard for ssh urls also.

* [2020-11-23 Mon] Pulled pork recipe
:PROPERTIES:
:CUSTOM_ID: pulled-pork-recipe
:END:
Made pulled pork a couple of times. Freestyled a bit. No expert here, but result was yummie.

** Grind/blend spices

- 2 teaspoons smoked paprika
- 2 teaspoons cumin seeds
- 2 teaspoons whole pepper corn mix
- 2 teaspoons chilly flakes

If spices are whole, grind or blend them. Set aside.

Optionally: Substitute 1 teaspoon of paprika with chipotle pepper.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/pulled-pork-recipe/grind.jpg]]

#+ATTR_HTML: :width 50% :height 50%
[[file:images/pulled-pork-recipe/ground.jpg]]

** Mix into a paste

- 2 tablespoons honey
- 1 teaspoon of dijon mustard

Mix the honey, mustard, and previous spices into a paste.

** Rub the mix in

Rub mix thoroughly into the pork shoulder.

** Bake (1 hour)

Place in a pot (lid off) and bake in the oven for 1 hour at 200 °C.

** Add liquids

- 1/2 cup of water.
- 4 tablespoons of apple cider vinegar.

Add liquids to pot.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/pulled-pork-recipe/almost.jpg]]

** Bake (3-5 hours)

Bake between 3 to 5 hours 150 °C. Check every hour or two. Does the meat fall easily when spread with two forks? If so, you're done.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/pulled-pork-recipe/out.jpg]]

** Pull apart

Use two forks to pull the meat apart.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/pulled-pork-recipe/final.jpg]]

* [2020-11-01 Sun] Zettelkasten bookmarks
:PROPERTIES:
:CUSTOM_ID: zettelkasten-bookmarks
:END:
:MODIFIED:
[2020-12-25 Fri]
:END:
- [[https://zettelkasten.de/introduction/][Introduction to the Zettelkasten Method]].
- [[https://blog.viktomas.com/posts/slip-box/#fnref:1][Zettelkasten note-taking in 10 minutes · Tomas Vik]].
* [2020-10-28 Wed] Battlestation bookmarks
:PROPERTIES:
:CUSTOM_ID: battlestation-bookmarks
:END:
:MODIFIED:
[2020-10-28 Wed]
:END:
- [[https://twitter.com/twostraws/status/1321064772276789248][Hacking with Swift's battlestation.]].
- [[https://www.reddit.com/r/battlestations/][/r/battlestations]].
* [2020-10-27 Tue] Emacs: chaining org babel blocks
  :PROPERTIES:
  :CUSTOM_ID: emacs-chaining-org-babel-blocks
  :END:
Recently wanted to chain org babel blocks. That is, aggregate separate source blocks and execute as one combined block.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-chaining-org-babel-blocks/chain.gif]]

I wanted the chaining primarily driven through header arguments as follows:

#+begin_src org
  ,#+name: block-0
  ,#+begin_src swift
    print("hello 0")
  ,#+end_src

  ,#+name: block-1
  ,#+begin_src swift :include block-0
    print("hello 1")
  ,#+end_src

  ,#+RESULTS: block-1
  : hello 0
  : hello 1
#+end_src

I didn't find the above syntax and behaviour supported out of the box (or didn't search hard enough?). Fortunately, this is our beloved and malleable editor, so we can always bend it our way! Wasn't quite sure how to go about it, so I looked at other babel packages for inspiration. [[https://github.com/astahlman/ob-async][ob-async]] was great for that.

Turns out, advicing /org-babel-execute-src-block/ did the job:

#+begin_src emacs-lisp
  (defun adviced:org-babel-execute-src-block (&optional orig-fun arg info params)
    (let ((body (nth 1 info))
          (include (assoc :include (nth 2 info)))
          (named-blocks (org-element-map (org-element-parse-buffer)
                            'src-block (lambda (item)
                                         (when (org-element-property :name item)
                                           (cons (org-element-property :name item)
                                                 item))))))
      (while include
        (unless (cdr include)
          (user-error ":include without value" (cdr include)))
        (unless (assoc (cdr include) named-blocks)
          (user-error "source block \"%s\" not found" (cdr include)))
        (setq body (concat (org-element-property :value (cdr (assoc (cdr include) named-blocks)))
                           body))
        (setf (nth 1 info) body)
        (setq include (assoc :include
                             (org-babel-parse-header-arguments
                              (org-element-property :parameters (cdr (assoc (cdr include) named-blocks)))))))
      (funcall orig-fun arg info params)))

  (advice-add 'org-babel-execute-src-block :around 'adviced:org-babel-execute-src-block)
#+end_src

Before I built my own support, I did find that [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]] got me most of what I needed, but required sprinkling blocks with placeholder references.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-chaining-org-babel-blocks/noweb.gif]]

Combining [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][:noweb]] and [[https://org-babel.readthedocs.io/en/latest/header-args/#prologue][:prologue]] would have been a great match, if only prologue did expand the noweb reference. I'm sure there's an alternative I'm missing. Either way, it was fun to poke at babel blocks and build my own chaining support.

* [2020-10-25 Sun] Emacs: quote wrap all in region
  :PROPERTIES:
  :CUSTOM_ID: emacs-quote-wrap-all-in-region
  :END:
As I find myself moving more shell commands into Emacs interactive commands to [[http://xenodium.com/emacs-create-a-swift-packageproject/][create a Swift package/project]], [[http://xenodium.com/enrich-your-dired-batching-toolbox/][enrich dired's featureset]], or [[http://xenodium.com/emacs-searchplay-music-macos/][search/play Music (macOS)]], I often need to take a single space-separated string, make an elisp list of strings, and feed it to functions like /process-lines/. No biggie, but I thought it'd be a fun little function to write: take the region and wrap all items in quotes. As a bonus, made it toggable.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-quote-wrap-all-in-region/wrap-toggle-region.gif]]

#+begin_src emacs-lisp
  (defun ar/toggle-quote-wrap-all-in-region (beg end)
    "Toggle wrapping all items in region with double quotes."
    (interactive (list (mark) (point)))
    (unless (region-active-p)
      (user-error "no region to wrap"))
    (let ((deactivate-mark nil)
          (replacement (string-join
                        (mapcar (lambda (item)
                                  (if (string-match-p "^\".*\"$" item)
                                      (string-trim item "\"" "\"")
                                    (format "\"%s\"" item)))
                                (split-string (buffer-substring beg end)))
                        " ")))
      (delete-region beg end)
      (insert replacement)))
#+end_src

* [2020-10-18 Sun] Emacs: org block complete and edit
  :PROPERTIES:
  :CUSTOM_ID: emacs-edit-after-org-block-completion
  :END:
I quickly got used to [[http://xenodium.com/emacs-org-block-company-completion/][Emacs org block company completion]]. I did, however, almost always found myself running /org-edit-special/ immediately after inserting completion. I use *C-c '* for that. That's all fine, but it just felt redundant.

Why not automatically edit the source block in corresponding major mode after completion? I think I can also get used to that!

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-edit-after-org-block-completion/automatic.gif]]

Or maybe the automatic approach is too eager? There's also a middle ground: ask immediately after.

#+ATTR_HTML: :width 50% :height 50%
[[file:images/emacs-edit-after-org-block-completion/prompted.gif]]

Or maybe I don't want either in the end? Time will tell, but I now have all three options available:

#+begin_src emacs-lisp
  (defcustom company-org-block-edit-mode 'auto
    "Customize whether edit mode, post completion was inserted."
    :type '(choice
            (const :tag "nil: no edit after insertion" nil)
            (const :tag "prompt: ask before edit" prompt)
            (const :tag "auto edit, no prompt" auto)))
#+end_src

The new option is now in the [[https://github.com/xenodium/dotsies/blob/main/emacs/ar/company-org-block.el][company-org-block snippet]] with my latest config.

* [2020-10-11 Sun] Emacs: create a Swift package/project
  :PROPERTIES:
  :CUSTOM_ID: emacs-create-a-swift-packageproject
  :END:
Been playing around with [[https://swift.org/package-manager/][Swift Package Manager (SPM)]]. Creating a new Swift package (ie. project) is pretty simple.

To create a library package, we can use the following:

#+begin_src sh
  swift package init --type library
#+end_src

Alternatively, to create a command-line utility use:

#+begin_src sh
  swift package init --type executable
#+end_src

Turns out, there are a few options: empty, library, executable, system-module, manifest.

With a little elisp, we can write a completing function to quickly generate a Swift package/project without the need to drop to the shell.

Bonus: I won't have to look up SPM options if I ever forget them.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-create-swift-package/swift-package.gif]]

#+begin_src emacs-lisp
  (defun ar/swift-package-init ()
    "Execute `swift package init', with optional name and completing type."
    (interactive)
    (let* ((name (read-string "name (default): "))
           (type (completing-read
                  "project type: "
                  ;; Splits "--type empty|library|executable|system-module|manifest"
                  (split-string
                   (nth 1 (split-string
                           (string-trim
                            (seq-find
                             (lambda (line)
                               (string-match "--type" line))
                             (process-lines "swift" "package" "init" "--help")))
                           "   "))
                   "|")))
           (command (format "swift package init --type %s" type)))
      (unless (string-empty-p name)
        (append command "--name " name))
      (shell-command command))
    (dired default-directory)
    (revert-buffer))
#+end_src
* [2020-10-04 Sun] Improved Ctrl-p/Ctrl-n macOS movement
  :PROPERTIES:
  :CUSTOM_ID: improved-ctrl-p-ctrl-n-macos-movement
  :END:
macOS supports many Emacs bindings (out of the box). You can, for example, press C-p and C-n to move the cursor up and down (whether editing text in Emacs or any other macOS app). Jacob Rus's [[http://www.hcs.harvard.edu/~jrus/site/cocoa-text.html][Customizing the Cocoa Text System]] offers a more in-depth picture and also shows how to customize global macOS keybindings (via DefaultKeyBinding.dict).

In addition to moving Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Point.html][point]] (cursor) up/down using C-p/C-n, I've internalized the same bindings to select an option from a list. Good Emacs examples of these are [[https://company-mode.github.io/][company mode]] and [[https://github.com/abo-abo/swiper][ivy]].

Vertical cursor movement using Emacs bindings works well in most macOS apps, including forms and text boxes in web pages. However, selecting from a completion list doesn't quite work as expected. Although the binding is technically handled, it moves the cursor within the text widget, ignoring the suggested choices.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/improved-ctrl-p-ctrl-n-macos-movement/bindings-borked.gif]]

Atif Afzal's [[https://www.atfzl.com/use-emacs-key-bindings-everywhere][Use emacs key bindings everywhere]] has a solution for the ignored case. He uses [[https://github.com/pqrs-org/Karabiner-Elements][Karabiner Elements]] to remap c-p and c-n to arrow-up and arrow-down.

It's been roughly a week since I started using the Karabiner remapping, and I've yet to find a case where a web page (or any other macOS app) did not respond to c-p and c-n to move selection from a list.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/improved-ctrl-p-ctrl-n-macos-movement/bindings-fixed.gif]]

My ~/.config/karabiner/karabiner.json configuration is as follows:

#+begin_src json
  {
      "global": {
          "check_for_updates_on_startup": true,
          "show_in_menu_bar": true,
          "show_profile_name_in_menu_bar": false
      },
      "profiles": [
          {
              "complex_modifications": {
                  "parameters": {
                      "basic.simultaneous_threshold_milliseconds": 50,
                      "basic.to_delayed_action_delay_milliseconds": 500,
                      "basic.to_if_alone_timeout_milliseconds": 1000,
                      "basic.to_if_held_down_threshold_milliseconds": 500,
                      "mouse_motion_to_scroll.speed": 100
                  },
                  "rules": [
                      {
                          "description": "Ctrl+p/Ctrl+n to arrow up/down",
                          "manipulators": [
                              {
                                  "from": {
                                      "key_code": "p",
                                      "modifiers": {
                                          "mandatory": [
                                              "control"
                                          ]
                                      }
                                  },
                                  "to": [
                                      {
                                          "key_code": "up_arrow"
                                      }
                                  ],
                                  "conditions": [
                                      {
                                          "type": "frontmost_application_unless",
                                          "bundle_identifiers": [
                                              "^org\\.gnu\\.Emacs"
                                          ]
                                      }
                                  ],
                                  "type": "basic"
                              },
                              {
                                  "from": {
                                      "key_code": "n",
                                      "modifiers": {
                                          "mandatory": [
                                              "control"
                                          ]
                                      }
                                  },
                                  "to": [
                                      {
                                          "key_code": "down_arrow"
                                      }
                                  ],
                                  "conditions": [
                                      {
                                          "type": "frontmost_application_unless",
                                          "bundle_identifiers": [
                                              "^org\\.gnu\\.Emacs"
                                          ]
                                      }
                                  ],
                                  "type": "basic"
                              }
                          ]
                      }
                  ]
              },
              "devices": [],
              "fn_function_keys": [],
              "name": "Default profile",
              "parameters": {
                  "delay_milliseconds_before_open_device": 1000
              },
              "selected": true,
              "simple_modifications": [],
              "virtual_hid_keyboard": {
                  "country_code": 0,
                  "mouse_key_xy_scale": 100
              }
          }
      ]
  }
#+end_src

** Bonus (C-g to exit)

Pressing Esc often dismisses or cancels macOS windows, menus, etc. This is also the case for web pages. As an Emacs user, I'm pretty used to pressing C-g to cancel, quit, or exit things. With that in mind, mapping C-g to Esc is surprisingly useful outside of Emacs. Here's the relevant Karabiner C-g binding for that:

#+begin_src json
  {
      "description": "Ctrl+G to Escape",
      "manipulators": [
          {
              "description": "emacs like escape",
              "from": {
                  "key_code": "g",
                  "modifiers": {
                      "mandatory": [
                          "left_control"
                      ]
                  }
              },
              "to": [
                  {
                      "key_code": "escape"
                  }
              ],
              "conditions": [
                  {
                      "type": "frontmost_application_unless",
                      "bundle_identifiers": [
                          "^org\\.gnu\\.Emacs"
                      ]
                  }
              ],
              "conditions": [
                  {
                      "type": "frontmost_application_unless",
                      "bundle_identifiers": [
                          "^org\\.gnu\\.Emacs"
                      ]
                  }
              ],
              "type": "basic"
          }
      ]
  }
#+end_src

UPDATE: Ensure bindings are only active when Emacs is _not_ active.
* [2020-10-04 Sun] Basmati rice pudding recipe
  :PROPERTIES:
  :CUSTOM_ID: basmati-rice-pudding-recipe
  :END:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/basmati-rice-pudding-recipe/rice_pudding.jpg]]

** Combine in a pot

- 2/3 cup of basmati rice
- 400 ml of coconut milk
- 4 cups of milk [1]
- 3 tablespoons of honey [2]
- 1/4 teaspoon of crushed cardamom seeds [3]
- 1/8 teaspoon of salt

Simple. Combine all ingredients in a pot.

[1] Been using powder milk since lockdown, end-result's been tasty.
[2] Only tried raw honey so far.
[3] Can likely use ground cardamom. I enjoy the scents while crushing.

** Boil and simmer

Bring ingredients to a boil and simmer at low heat for 45 minutes. Stir occasionally.

** Mix in butter

- 1 tablespoon of butter.

Turn stove off, add a tablespoon of butter, and mix in.

** Serve warm or cold

After mixing in the butter, the rice pudding is done. You can serve warm or cold.

** Garnish (optional)

- Pistachios
- Cinnamon

Optionally garnish with either pistachios or cinnamon (or both).

* [2020-09-27 Sun] Adding images to pdfs (macOS)
  :PROPERTIES:
  :CUSTOM_ID: adding-images-to-pdfs-macos
  :END:
The macOS Preview app does a great job inserting signatures to existing pdfs. I was hoping it could overlay images just as easily. Doesn't look like it's possible, without exporting/reimporting to image formats and losing pdf structure. Did I miss something?

In any case, I found [[https://code.google.com/archive/p/formulatepro/][formulatepro]]. Dormant at Google Code Archive, but also [[https://github.com/adlr/formulatepro][checked in to github]]. With a tiny [[https://github.com/xenodium/formulatepro/commit/cd43b1e73c2f180f4b4b7fb11fdec975b6960dc6][patch]], it builds and runs on Catalina. One can easily insert an image via "File > Place Image...".

#+ATTR_HTML: :width 75% :height 75%
[[file:images/adding-images-to-pdfs-macos/formulatepro.png]]

* [2020-09-27 Sun] DIY bookmarks
  :PROPERTIES:
  :CUSTOM_ID: diy-bookmarks
  :END:
:MODIFIED:
[2020-10-19 Mon]
:END:
- [[https://linuxhint.com/best_electrical_insulation_tape/][Best electrical insulation tape]].
- [[https://twitter.com/rosen/status/1317843289530376196][I’ve spent the last 3 months building the home office of my dreams]].

* [2020-09-24 Thu] Skiing bookmarks
  :PROPERTIES:
  :CUSTOM_ID: skiing-bookmarks
  :END:
- [[https://www.lonelyplanet.com/articles/remote-ski-resorts-europe][7 far-flung European ski resorts - Lonely Planet]].

* [2020-09-19 Sat] Emacs: search/play Music (macOS)
  :PROPERTIES:
  :CUSTOM_ID: emacs-searchplay-music-macos
  :END:
While trying out macOS's Music app to manage offline media, I wondered if I could easily search and control playback from Emacs. Spoiler alert: yes it can be done and fuzzy searching music is rather gratifying.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-searchplay-music-macos/music_search.gif]]

Luckily, the hard work's already handled by [[https://github.com/hile/pytunes][pytunes]], a command line interface to macOS's iTunes/Music app. We add [[https://ffmpeg.org/ffprobe.html][ffprobe]] and some elisp glue to the mix, and we can generate an Emacs media index.

Indexing takes roughly a minute per 1000 files. Prolly suboptimal, but I don't intend to re-index frequently. For now, we can use a separate process to prevent Emacs from blocking, so we can get back to playing tetris from our beloved editor:

#+begin_src emacs-lisp
  (defun musica-index ()
    "Indexes Music's tracks in two stages:
  1. Generates \"Tracks.sqlite\" using pytunes (needs https://github.com/hile/pytunes installed).
  2. Caches an index at ~/.emacs.d/.musica.el."
    (interactive)
    (message "Indexing music... started")
    (let* ((now (current-time))
           (name "Music indexing")
           (buffer (get-buffer-create (format "*%s*" name))))
      (with-current-buffer buffer
        (delete-region (point-min)
                       (point-max)))
      (set-process-sentinel
       (start-process name
                      buffer
                      (file-truename (expand-file-name invocation-name
                                                       invocation-directory))
                      "--quick" "--batch" "--eval"
                      (prin1-to-string
                       `(progn
                          (interactive)
                          (require 'cl-lib)
                          (require 'seq)
                          (require 'map)

                          (message "Generating Tracks.sqlite...")
                          (process-lines "pytunes" "update-index") ;; Generates Tracks.sqlite
                          (message "Generating Tracks.sqlite... done")

                          (defun parse-tags (path)
                            (with-temp-buffer
                              (if (eq 0 (call-process "ffprobe" nil t nil "-v" "quiet"
                                                      "-print_format" "json" "-show_format" path))
                                  (map-elt (json-parse-string (buffer-string)
                                                              :object-type 'alist)
                                           'format)
                                (message "Warning: Couldn't read track metadata for %s" path)
                                (message "%s" (buffer-string))
                                (list (cons 'filename path)))))

                          (let* ((paths (process-lines "sqlite3"
                                                       (concat (expand-file-name "~/")
                                                               "Music/Music/Music Library.musiclibrary/Tracks.sqlite")
                                                       "select path from tracks"))
                                 (total (length paths))
                                 (n 0)
                                 (records (seq-map (lambda (path)
                                                     (let ((tags (parse-tags path)))
                                                       (message "%d/%d %s" (setq n (1+ n))
                                                                total (or (map-elt (map-elt tags 'tags) 'title) "No title"))
                                                       tags))
                                                   paths)))
                            (with-temp-buffer
                              (prin1 records (current-buffer))
                              (write-file "~/.emacs.d/.musica.el" nil))))))
       (lambda (process state)
         (if (= (process-exit-status process) 0)
             (message "Indexing music... finished (%.3fs)"
                      (float-time (time-subtract (current-time) now)))
           (message "Indexing music... failed, see %s" buffer))))))
#+end_src

Once media is indexed, we can feed it to [[https://github.com/abo-abo/swiper][ivy]] for that narrowing-down fuzzy-searching goodness! It's worth mentioning the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Size-of-Displayed-Text.html][truncate-string-to-width]] function. Super handy for truncating strings to a fixed width and visually organizing search results in columns.

#+begin_src emacs-lisp
  (defun musica-search ()
    (interactive)
    (cl-assert (executable-find "pytunes") nil "pytunes not installed")
    (let* ((c1-width (round (* (- (window-width) 9) 0.4)))
           (c2-width (round (* (- (window-width) 9) 0.3)))
           (c3-width (- (window-width) 9 c1-width c2-width)))
      (ivy-read "Play: " (mapcar
                          (lambda (track)
                            (let-alist track
                              (cons (format "%s   %s   %s"
                                            (truncate-string-to-width
                                             (or .tags.title
                                                 (file-name-base .filename)
                                                 "No title") c1-width nil ?\s "…")
                                            (truncate-string-to-width (propertize (or .tags.artist "")
                                                                                  'face '(:foreground "yellow")) c2-width nil ?\s "…")
                                            (truncate-string-to-width
                                             (propertize (or .tags.album "")
                                                         'face '(:foreground "cyan1")) c3-width nil ?\s "…"))
                                    track)))
                          (musica--index))
                :action (lambda (selection)
                          (let-alist (cdr selection)
                            (process-lines "pytunes" "play" .filename)
                            (message "Playing: %s [%s] %s"
                                     (or .tags.title
                                         (file-name-base .filename)
                                         "No title")
                                     (or .tags.artist
                                         "No artist")
                                     (or .tags.album
                                         "No album")))))))

  (defun musica--index ()
    (with-temp-buffer
      (insert-file-contents "~/.emacs.d/.musica.el")
      (read (current-buffer))))
#+end_src

The remaining bits are straigtforward. We add a few interactive functions to control playback:

#+begin_src emacs-lisp
  (defun musica-info ()
    (interactive)
    (let ((raw (process-lines "pytunes" "info")))
      (message "%s [%s] %s"
               (string-trim (string-remove-prefix "Title" (nth 3 raw)))
               (string-trim (string-remove-prefix "Artist" (nth 1 raw)))
               (string-trim (string-remove-prefix "Album" (nth 2 raw))))))

  (defun musica-play-pause ()
    (interactive)
    (cl-assert (executable-find "pytunes") nil "pytunes not installed")
    (process-lines "pytunes" "play")
    (musica-info))

  (defun musica-play-next ()
    (interactive)
    (cl-assert (executable-find "pytunes") nil "pytunes not installed")
    (process-lines "pytunes" "next"))

  (defun musica-play-next-random ()
    (interactive)
    (cl-assert (executable-find "pytunes") nil "pytunes not installed")
    (process-lines "pytunes" "shuffle" "enable")
    (let-alist (seq-random-elt (musica--index))
      (process-lines "pytunes" "play" .filename))
    (musica-info))

  (defun musica-play-previous ()
    (interactive)
    (cl-assert (executable-find "pytunes") nil "pytunes not installed")
    (process-lines "pytunes" "previous"))
#+end_src

Finally, if we want some convenient keybindings, we can add something like:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c m SPC") #'musica-play-pause)
  (global-set-key (kbd "C-c m i") #'musica-info)
  (global-set-key (kbd "C-c m n") #'musica-play-next)
  (global-set-key (kbd "C-c m p") #'musica-play-previous)
  (global-set-key (kbd "C-c m r") #'musica-play-next-random)
  (global-set-key (kbd "C-c m s") #'musica-search)
#+end_src

Hooray! Controlling music is now an Emacs keybinding away: \o/

comments on [[https://twitter.com/xenodium/status/1307294369326731264][twitter]].

UPDATE1: Installing pytunes with /pip3 install pytunes/ didn't just work for me. Instead, I cloned and installed as:

#+begin_src sh
  git clone https://github.com/hile/pytunes
  pip3 install file:///path/to/pytunes
  pip3 install pytz
  brew install libmagic
#+end_src

UPDATE2: Checked in to [[https://github.com/xenodium/dotsies/blob/master/emacs/ar/musica.el][dot files]].

* [2020-09-12 Sat] Cheese cake recipe (no crust)
  :PROPERTIES:
  :CUSTOM_ID: cheese-cake-recipe-no-crust
  :END:
#+ATTR_HTML: :width 75% :height 75%
[[file:images/cheese-cake-recipe-no-crust/berried.jpg]]

#+ATTR_HTML: :width 75% :height 75%
[[file:images/cheese-cake-recipe-no-crust/inoven.jpg]]

** Preheat oven

Preheat oven at 175°C.

** Ingredients at room temperature

Ensure the cream cheese, sour cream, and eggs are at room temperature before starting.

** Mix cream cheese

- 900g of cream cheese

Mix the cream cheese thoroughly.

** Mix sugar

- 240g of sugar

Add half the sugar. Mix in thoroughly. Add second half and mix.

** Mix sour cream, corn flour, and vanilla.

- 100g sour cream
- 40g corn flour
- 1tbsp vanilla bean paste

Add the three ingredients and mix well.

** Mix eggs

- 3 eggs
- 1 egg yolk

Add the eggs and mix for 30 seconds.

** Mix by hand

Finish mixing thoroughly by hand, using a wooden spoon.

** Prepare pan

- Springform pan
- Parchment paper

A springform pan works best here. Wrap its plate with parchment paper and lock it in place.

** Pour mix

- Strainer

Pour the mix through a strainer and into the prepared pan.

** Rest mix

Let the mix rest in the pan for 10 minutes to let air bubbles out.

** Bake

Bake for an 1 hour 10 minutes. Maybe add another 10 minutes (or more) if surface is still pale. Turn the oven off, leave door half open, and let it sit for 20 minutes.

** Cool off

Take out and let it cool off to room temperature.

** Refrigerate

Refrigerate for 4 hours (or overnight) before removing the sides of the pan.

** Eat!

Nom nom. Yum yum.

** Bonus (topping)

I winged this one and it worked out well. Heated up frozen berries with some honey and used it as topping. The whole combo was pretty tasty.

* [2020-08-28 Fri] Faster macOS dock auto-hide
  :PROPERTIES:
  :CUSTOM_ID: faster-macos-dock-auto-hide
  :END:
#+ATTR_HTML: :width 75% :height 75%
[[file:images/faster-macos-dock-auto-hide/dock.gif]]

Via Marcin Swieczkowski's [[https://www.bytedude.com/upgrading-the-osx-dock/][Upgrading The OSX Dock]], change default to make macOS's dock auto-hide faster:

#+begin_src bash
  defaults write com.apple.dock autohide-time-modifier -float 0.2; killall Dock
#+end_src

* [2020-08-25 Tue] Smarter Swift snippets
  :PROPERTIES:
  :CUSTOM_ID: smarter-snippets
  :END:
[[https://twitter.com/safijari][Jari Safi]] published a wonderful Emacs video [[https://youtu.be/xmBovJvQ3KU][demoing python yasnippets in action]]. The constructor snippet, automatically setting ivars, is just magical. I wanted it for Swift!

I took a look at the [[https://github.com/jorgenschaefer/elpy/blob/060a4eb78ec8eba9c8fe3466c40a414d84b3dc81/snippets/python-mode/__init__][__init__ snippet]] from [[https://github.com/jorgenschaefer][Jorgen Schäfer]]'s [[https://github.com/jorgenschaefer/elpy][elpy]]. It uses [[https://github.com/jorgenschaefer/elpy/blob/060a4eb78ec8eba9c8fe3466c40a414d84b3dc81/snippets/python-mode/.yas-setup.el#L33][elpy-snippet-init-assignments]] to generate the assignments.

With small tweaks, we can get the same action going on for Swift \o/

#+ATTR_HTML: :width 75% :height 75%
[[file:images/smarter-snippets/snippet.gif]]

init.yasnippet:

#+begin_src snippet
  # -*- mode: snippet -*-
  # name: init with assignments
  # key: init
  # --
  init(${1:, args}) {
    ${1:$(swift-snippet-init-assignments yas-text)}
  }
  $0
#+end_src

.yas-setup.el:

#+begin_src emacs-lisp
  (defun swift-snippet-init-assignments (arg-string)
    (let ((indentation (make-string (save-excursion
                                      (goto-char start-point)
                                      (current-indentation))
                                    ?\s)))
      (string-trim (mapconcat (lambda (arg)
                                (if (string-match "^\\*" arg)
                                    ""
                                  (format "self.%s = %s\n%s"
                                          arg arg indentation)))
                              (swift-snippet-split-args arg-string)
                              ""))))

  (defun swift-snippet-split-args (arg-string)
    (mapcar (lambda (x)
              (if (and x (string-match "\\([[:alnum:]]*\\):" x))
                  (match-string-no-properties 1 x)
                x))
            (split-string arg-string "[[:blank:]]*,[[:blank:]]*" t)))
#+end_src
* [2020-08-23 Sun] Swift package manager build for iOS
  :PROPERTIES:
  :CUSTOM_ID: swift-package-manager-build-for-ios
  :END:
While playing around with Swift package manager, it wasn't immediately obvious how to build for iOS from the command line. The default behaviour of invoking /swift build/ is to build for the host. In my case, macOS. In any case, this was it:

#+begin_src sh
  swift build -Xswiftc "-sdk" -Xswiftc "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.0.sdk" -Xswiftc "-target" -Xswiftc "x86_64-apple-ios13.0-simulator"
#+end_src

ps. Can get the SDK path with:

#+begin_src sh
  xcrun --sdk iphonesimulator --show-sdk-path
#+end_src

* [2020-08-23 Sun] QR code bookmarks
  :PROPERTIES:
  :CUSTOM_ID: qr-code-bookmarks
  :END:
:MODIFIED:
[2020-12-26 Sat]
:END:
- [[https://github.com/divan/txqr][divan/txqr: Transfer data via animated QR codes]].
- [[https://research.swtch.com/qart][research!rsc: QArt Codes]].
- [[https://news.ycombinator.com/item?id=24158125][Show HN: Photo Realistic QR-Codes (Hacker News)]].
* [2020-08-16 Sun] Trying out gccemacs on macOS
  :PROPERTIES:
  :CUSTOM_ID: trying-out-gccemacs-on-macos
  :END:

/UPDATE: I'm no longer using these steps. See [[https://xenodium.com/emacs-plus-with-native-comp/][Emacs plus --with-native-comp]] for an easier alternative./

Below are the instructions I use to build Andrea Corallo's [[http://akrl.sdf.org/gccemacs.html][gccemacs]] on macOS. It is based on [[https://github.com/AllenDang][Allen Dang]]'s handy [[https://gist.github.com/AllenDang/f019593e65572a8e0aefc96058a2d23e][instructions]] plus some changes of my own.

** Install gcc and libgccjit via homebrew

#+begin_src sh
  brew install gcc libgccjit
#+end_src

** Save configure script

Create configure-gccemacs.sh

#+begin_src sh
  #!/bin/bash

  set -o nounset
  set -o errexit

  # Configures Emacs for building native comp support
  # http://akrl.sdf.org/gccemacs.html

  readonly GCC_DIR="$(realpath $(brew --prefix libgccjit))"
  [[ -d $GCC_DIR ]] ||  { echo "${GCC_DIR} not found"; exit 1; }

  readonly SED_DIR="$(realpath $(brew --prefix gnu-sed))"
  [[ -d $SED_DIR ]] ||  { echo "${SED_DIR} not found"; exit 1; }

  readonly GCC_INCLUDE_DIR=${GCC_DIR}/include
  [[ -d $GCC_INCLUDE_DIR ]] ||  { echo "${GCC_INCLUDE_DIR} not found"; exit 1; }

  readonly GCC_LIB_DIR=${GCC_DIR}/lib/gcc/10
  [[ -d $GCC_LIB_DIR ]] ||  { echo "${GCC_LIB_DIR} not found"; exit 1; }

  export PATH="${SED_DIR}/libexec/gnubin:${PATH}"
  export CFLAGS="-O2 -I${GCC_INCLUDE_DIR}"
  export LDFLAGS="-L${GCC_LIB_DIR} -I${GCC_INCLUDE_DIR}"
  export LD_LIBRARY_PATH="${GCC_LIB_DIR}"
  export DYLD_FALLBACK_LIBRARY_PATH="${GCC_LIB_DIR}"

  echo "Environment"
  echo "-----------"
  echo PATH: $PATH
  echo CFLAGS: $CFLAGS
  echo LDFLAGS: $LDFLAGS
  echo DYLD_FALLBACK_LIBRARY_PATH: $DYLD_FALLBACK_LIBRARY_PATH
  echo "-----------"

  ./autogen.sh

  ./configure \
       --prefix="$PWD/nextstep/Emacs.app/Contents/MacOS" \
       --enable-locallisppath="${PWD}/nextstep/Emacs.app/Contents/MacOS" \
       --with-mailutils \
       --with-ns \
       --with-imagemagick \
       --with-cairo \
       --with-modules \
       --with-xml2 \
       --with-gnutls \
       --with-json \
       --with-rsvg \
       --with-native-compilation \
       --disable-silent-rules \
       --disable-ns-self-contained \
       --without-dbus
#+end_src

Make it executable

#+begin_src shell
  chmod +x configure-gccemacs.sh
#+end_src

** Clone Emacs source

#+begin_src shell
  git clone --branch master https://github.com/emacs-mirror/emacs gccemacs
#+end_src

** Configure build

#+begin_src sh
  cd gccemacs
  ../configure-gccemacs.sh
#+end_src

** Native lisp compiler found?

Verify native lisp compiler is found:

#+begin_src fundamental
  Does Emacs have native lisp compiler?                   yes
#+end_src

** Build

Put those cores to use. Find out how many you got with:

#+begin_src sh
  sysctl hw.logicalcpu
#+end_src

#+RESULTS:
: hw.logicalcpu: 4

Ok so build with:

#+begin_src sh
  make -j4 NATIVE_FAST_BOOT=1
  cp -r lisp nextstep/Emacs.app/Contents/Resources/
  cp -r native-lisp nextstep/Emacs.app/Contents
  make install
#+end_src

*Note:* Using /NATIVE_FAST_BOOT=1/ significantly improves build time (totalling between 20-30 mins, depending on your specs). Without it, the build can take *hours*.

The macOS app build (under nextstep/Emacs.app) is ready, but read on before launching.

** Remove ~/emacs.d

You likely want to start with a clean install, byte-compiling all packages with the latest Emacs version. In any case, rename ~/emacs.d (for backup?) or remove ~/emacs.d.

** init.el config

Ensure /exec-path/ includes the script's "--prefix=" value, /LIBRARY_PATH/ points to gcc's lib dir, and finally set /comp-deferred-compilation/. I wrapped the snippet in my  /exec-path-from-shell/ config, but setting early in init.el should be enough.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize)
    (if (and (fboundp 'native-comp-available-p)
             (native-comp-available-p))
        (progn
          (message "Native comp is available")
          ;; Using Emacs.app/Contents/MacOS/bin since it was compiled with
          ;; ./configure --prefix="$PWD/nextstep/Emacs.app/Contents/MacOS"
          (add-to-list 'exec-path (concat invocation-directory "bin") t)
          (setenv "LIBRARY_PATH" (concat (getenv "LIBRARY_PATH")
                                         (when (getenv "LIBRARY_PATH")
                                           ":")
                                         ;; This is where Homebrew puts gcc libraries.
                                         (car (file-expand-wildcards
                                               (expand-file-name "~/homebrew/opt/gcc/lib/gcc/*")))))
          ;; Only set after LIBRARY_PATH can find gcc libraries.
          (setq comp-deferred-compilation t))
      (message "Native comp is *not* available")))
#+end_src

** Launch Emacs.app

You're good to go. Open Emacs.app via finder or shell:

#+begin_src sh
  open nextstep/Emacs.app
#+end_src

** Deferred compilation logs

After setting /comp-deferred-compilation/ (in init.el config section), .elc files should be asyncronously compiled. Function definition should be updated to native compiled equivalent.

Look out for an **Async-native-compile-log** buffer. Should have content like:

#+begin_src fundamental
  Compiling .emacs.d/elpa/moody-20200514.1946/moody.el...
  Compiling .emacs.d/elpa/minions-20200522.1052/minions.el...
  Compiling .emacs.d/elpa/persistent-scratch-20190922.1046/persistent-scratch.el...
  Compiling .emacs.d/elpa/which-key-20200721.1927/which-key.el...
  ...
#+end_src

Can also check for .eln files:

#+begin_src sh
  find ~/.emacs.d -iname *.eln | wc -l
#+end_src

#+RESULTS:
: 149

UPDATE1: Added /Symlink Emacs.app/Contents/eln-cache/ section for [[http://akrl.sdf.org/gccemacs.html#org4b11ea1][update 11]].

UPDATE2: Noted using NATIVE_FAST_BOOT makes the build much faster.

UPDATE3: Removed symlinks and copied content instead. This simplifies things. Inspired by Ian Wahbe's [[https://github.com/iwahbe/doom-config/blob/master/build-emacs.sh][build-emacs.sh]].

UPDATE4: Removed homebrew recipe patching. Thanks to Dmitry Shishkin's [[https://github.com/shshkn/emacs.d/blob/master/docs/nativecomp.md][instructions]].

UPDATE5: Use new flag --with-native-compilation and master branch.
* [2020-08-02 Sun] SwiftUI macOS desk clock
:PROPERTIES:
:CUSTOM_ID: swiftui-desk-clock
:END:

[[file:images/swiftui-desk-clock/everclock.gif]]

For time display, I've gone back and forth between an always-displayed macOS's menu bar to an auto-hide menu bar, and letting Emacs display the time. Neither felt great nor settled.

With some tweaks, Paul Hudson's [[https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-a-timer-with-swiftui][How to use a timer with SwiftUI]], led me to build a simple desk clock. Ok, let's not get fancy. It's really just an always-on-top floating window, showing a swiftUI label, but hey I like the minimalist feel ;)

Let's see if it sticks around or it gets in the way... Either way, here's standalone snippet. Run with /swift deskclock.swift/.

#+begin_src swift
  import Cocoa
  import SwiftUI

  let application = NSApplication.shared
  let appDelegate = AppDelegate()
  NSApp.setActivationPolicy(.regular)
  application.delegate = appDelegate
  application.mainMenu = NSMenu.makeMenu()
  application.run()

  struct ClockView: View {
    @State var time = "--:--"

    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    var body: some View {
      GeometryReader { geometry in

        VStack {
          Text(time)
            .onReceive(timer) { input in
              let formatter = DateFormatter()
              formatter.dateFormat = "HH:mm"
              time = formatter.string(from: input)
            }
            .font(.system(size: 40))
            .padding()
        }.frame(width: geometry.size.width, height: geometry.size.height)
          .background(Color.black)
          .cornerRadius(10)
          .frame(maxWidth: .infinity, maxHeight: .infinity)
      }
    }
  }

  extension NSWindow {
    static func makeWindow() -> NSWindow {
      let window = NSWindow(
        contentRect: NSRect.makeDefault(),
        styleMask: [.closable, .miniaturizable, .resizable, .fullSizeContentView],
        backing: .buffered, defer: false)
      window.level = .floating
      window.setFrameAutosaveName("everclock")
      window.collectionBehavior = [.canJoinAllSpaces, .stationary, .ignoresCycle, .fullScreenPrimary]
      window.makeKeyAndOrderFront(nil)
      window.isMovableByWindowBackground = true
      window.titleVisibility = .hidden
      window.backgroundColor = .clear
      return window
    }
  }

  class AppDelegate: NSObject, NSApplicationDelegate {
    var window = NSWindow.makeWindow()
    var hostingView: NSView?

    func applicationDidFinishLaunching(_ notification: Notification) {
      hostingView = NSHostingView(rootView: ClockView())
      window.contentView = hostingView
      NSApp.activate(ignoringOtherApps: true)
    }
  }

  extension NSRect {
    static func makeDefault() -> NSRect {
      let initialMargin = CGFloat(60)
      let fallback = NSRect(x: 0, y: 0, width: 100, height: 150)

      guard let screenFrame = NSScreen.main?.frame else {
        return fallback
      }

      return NSRect(
        x: screenFrame.maxX - fallback.width - initialMargin,
        y: screenFrame.maxY - fallback.height - initialMargin,
        width: fallback.width, height: fallback.height)
    }
  }

  extension NSMenu {
    static func makeMenu() -> NSMenu {
      let appMenu = NSMenuItem()
      appMenu.submenu = NSMenu()

      appMenu.submenu?.addItem(
        NSMenuItem(
          title: "Quit \(ProcessInfo.processInfo.processName)",
          action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q"
        ))

      let mainMenu = NSMenu(title: "Main Menu")
      mainMenu.addItem(appMenu)
      return mainMenu
    }
  }

#+end_src
* [2020-07-30 Thu] Mending bookmarks
  :PROPERTIES:
  :CUSTOM_ID: mending-bookmarks
  :END:
- [[https://youtu.be/S6UfWgMDlkQ][12 Great Sewing Tips and Tricks ! Best great sewing tips and tricks #7 - YouTube]].
* [2020-06-17 Wed] ffmpeg bookmarks
  :PROPERTIES:
  :CUSTOM_ID: ffmpeg-bookmarks
  :END:
:MODIFIED:
[2021-05-02 Sun]
:END:
- [[https://news.ycombinator.com/item?id=23540704][FFmpeg 4.3 (Hacker News)]].
- [[https://news.ycombinator.com/item?id=26370704][FFMPEG from Zero to Hero | Hacker News]].
- [[https://el-tramo.be/blog/ken-burns-ffmpeg/][Ken Burns Effect Slideshows with FFMPeg (mko.re)]].
- [[https://ottverse.com/stack-videos-horizontally-vertically-grid-with-ffmpeg/][Stack Videos Horizontally, Vertically, in a Grid With FFmpeg - OTTVerse]].
* [2020-06-14 Sun] Black lives matter (BLM) bookmarks
  :PROPERTIES:
  :CUSTOM_ID: black-lives-matter-blm-bookmarks
  :END:
- [[https://projects.fivethirtyeight.com/racism-polls/][Do You Know How Divided White And Black Americans Are On Racism? (FiveThirtyEight)]].
- [[https://marker.medium.com/its-time-we-dealt-with-white-supremacy-in-tech-8f7816fe809][It’s Time We Dealt With White Supremacy in Tech]].
- [[https://www.politico.com/magazine/story/2014/05/religious-right-real-origins-107133][The Real Origins of the Religious Right - POLITICO Magazine]].
* [2020-06-14 Sun] Dogs bookmarks
  :PROPERTIES:
  :CUSTOM_ID: dogs-bookmarks
  :END:
  - [[https://thedogspov.com/need-know-romanian-rescue-dogs/][All You Need to Know About Romanian Rescue Dogs]].
* [2020-06-06 Sat] Emacs, search hackingwithswift.com
  :PROPERTIES:
  :CUSTOM_ID: emacs-search-hackingwithswiftcom
  :END:
#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-search-hackingwithswiftcom/hws.gif]]

[[https://twitter.com/twostraws][Paul Hudson]] authors excellent Swift material at [[https://www.hackingwithswift.com/][hackingwithswift.com]]. I regularly land on the site while searching for snippets from the browser. I was wondering if I could search for snippets directly from Emacs.

Turns out, hackingwithswift uses a JSON HTTP request for querying code examples. With this in mind, we can use /ivy-read/ like Oleh Krehel's [[https://github.com/abo-abo/swiper/blob/8d840b2e8680e2768edb794c9ccecf975f6ba4cf/counsel.el#L6680][counsel-search]] and search for Swift snippets from our favorite editor:

#+begin_src emacs-lisp
  (require 'request)
  (require 'json)

  (defun ar/counsel-hacking-with-swift-search ()
    "Ivy interface to query hackingwithswift.com."
    (interactive)
    (ivy-read "hacking with swift: "
              (lambda (input)
                (or
                 (ivy-more-chars)
                 (let ((request-curl-options (list "-H" (string-trim (url-http-user-agent-string)))))
                   (request
                     "https://www.hackingwithswift.com/example-code/search"
                     :type "GET"
                     :params (list
                              (cons "search" input))
                     :parser 'json-read
                     :success (cl-function
                               (lambda (&key data &allow-other-keys)
                                 (ivy-update-candidates
                                  (mapcar (lambda (item)
                                            (let-alist item
                                              (propertize .title 'url .url)))
                                          data)))))
                   0)))
              :action (lambda (selection)
                        (browse-url (concat "https://www.hackingwithswift.com"
                                            (get-text-property 0 'url selection))))
              :dynamic-collection t
              :caller 'ar/counsel-hacking-with-swift-search))
#+end_src
* [2020-05-23 Sat] Preview SwiftUI layouts using Emacs org blocks
:PROPERTIES:
:CUSTOM_ID: swiftui-layout-previews-using-emacs-org-blocks
:END:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/swiftui-layout-previews-using-emacs-org-blocks/ob-swiftui.gif]]

✨ /UPDATE: The snippets in this post are outdated. See [[https://github.com/xenodium/ob-swiftui][ob-swiftui]] for better SwiftUI babel support/. ✨

Chris Eidhof [[https://twitter.com/chriseidhof/status/1261360332594974721][twitted]] a handy [[https://gist.github.com/chriseidhof/26768f0b63fa3cdf8b46821e099df5ff][snippet]] that enables quickly bootstrapping throwaway SwiftUI code. It can be easily integrated into other tools for rapid experimentation.

Being a SwiftUI noob, I could use some SwiftUI integration with my editor of choice. With some elisp glue and a small patch, Chris's snippet can be used to generate SwiftUI inline previews using Emacs org babel. This is particularly handy for playing around with SwiftUI layouts.

We can piggyback ride off zweifisch's [[https://github.com/zweifisch/ob-swift][ob-swift]] by advicing /org-babel-execute:swift/ to inject the org source block into the bootstrapping snippet. We also add a hook to /org-babel-after-execute-hook/ to automatically refresh the inline preview.

If you're a [[https://github.com/jwiegley/use-package][use-package]] user, the following snippet should make things fairly self-contained (if you have [[https://melpa.org/][melpa]] set up already).

#+begin_src emacs-lisp
  (use-package org
    :hook ((org-mode . org-display-inline-images))
    :config

    (use-package ob
      :config

      (use-package ob-swift
        :ensure t
        :config
        (org-babel-do-load-languages 'org-babel-load-languages
                                     (append org-babel-load-languages
                                             '((swift     . t))))

        (defun ar/org-refresh-inline-images ()
          (when org-inline-image-overlays
            (org-redisplay-inline-images)))

        ;; Automatically refresh inline images.
        (add-hook 'org-babel-after-execute-hook 'ar/org-refresh-inline-images)

        (defun adviced:org-babel-execute:swift (f &rest args)
          "Advice `adviced:org-babel-execute:swift' enabling swiftui header param."
          (let* ((body (nth 0 args))
                 (params (nth 1 args))
                 (swiftui (cdr (assoc :swiftui params)))
                 (output))
            (when swiftui
              (assert (or (string-equal swiftui "preview")
                          (string-equal swiftui "interactive"))
                      nil ":swiftui must be either preview or interactive")
              (setq body (format
                          "
  import Cocoa
  import SwiftUI
  import Foundation

  let screenshotURL = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true).appendingPathComponent(ProcessInfo.processInfo.globallyUniqueString + \".png\")
  let preview = %s

  NSApplication.shared.run {
    %s
  }

  extension NSApplication {
    public func run<V: View>(@ViewBuilder view: () -> V) {
      let appDelegate = AppDelegate(view())
      NSApp.setActivationPolicy(.regular)
      mainMenu = customMenu
      delegate = appDelegate
      run()
    }
  }

  extension NSApplication {
    var customMenu: NSMenu {
      let appMenu = NSMenuItem()
      appMenu.submenu = NSMenu()

      let quitItem = NSMenuItem(
        title: \"Quit \(ProcessInfo.processInfo.processName)\",
        action: #selector(NSApplication.terminate(_:)), keyEquivalent: \"q\")
      quitItem.keyEquivalentModifierMask = []
      appMenu.submenu?.addItem(quitItem)

      let mainMenu = NSMenu(title: \"Main Menu\")
      mainMenu.addItem(appMenu)
      return mainMenu
    }
  }

  class AppDelegate<V: View>: NSObject, NSApplicationDelegate, NSWindowDelegate {
    var window = NSWindow(
      contentRect: NSRect(x: 0, y: 0, width: 414 * 0.2, height: 896 * 0.2),
      styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
      backing: .buffered, defer: false)

    var contentView: V

    init(_ contentView: V) {
      self.contentView = contentView
    }

    func applicationDidFinishLaunching(_ notification: Notification) {
      window.delegate = self
      window.center()
      window.contentView = NSHostingView(rootView: contentView)
      window.makeKeyAndOrderFront(nil)

      if preview {
        screenshot(view: window.contentView!, saveTo: screenshotURL)
        // Write path (without newline) so org babel can parse it.
        print(screenshotURL.path, terminator: \"\")
        NSApplication.shared.terminate(self)
        return
      }

      window.setFrameAutosaveName(\"Main Window\")
      NSApp.activate(ignoringOtherApps: true)
    }
  }

  func screenshot(view: NSView, saveTo fileURL: URL) {
    let rep = view.bitmapImageRepForCachingDisplay(in: view.bounds)!
    view.cacheDisplay(in: view.bounds, to: rep)
    let pngData = rep.representation(using: .png, properties: [:])
    try! pngData?.write(to: fileURL)
  }
  "
                          (if (string-equal swiftui "preview")
                              "true"
                            "false")
                          body))
              (setq args (list body params)))
            (setq output (apply f args))
            (when org-inline-image-overlays
              (org-redisplay-inline-images))
            output))

        (advice-add #'org-babel-execute:swift
                    :around
                    #'adviced:org-babel-execute:swift))))
#+end_src

+Snippet also at github [[https://gist.github.com/xenodium/79154033bc26e733b8c43af228cbce5b][gist]] and included in [[https://github.com/xenodium/dotsies/blob/master/emacs/features/fe-org.el][my emacs config]]+.

/UPDATE: See [[https://github.com/xenodium/ob-swiftui][ob-swiftui]] for a better version of babel SwiftUI support./

Once the snippet is evaluated, we're ready to use in an org babel block. We introduced the /:swiftui/ header param to switch between inline static /preview/ and /interactive/ mode.

To try out an inline /preview/, create a new org file (eg. swiftui.org) and a source block like:

#+begin_src org :exports src
  ,#+begin_src swift :results file :swiftui preview
    VStack(spacing: 10) {
        HStack(spacing: 10) {
          Rectangle().fill(Color.yellow)
          Rectangle().fill(Color.green)
        }
        Rectangle().fill(Color.blue)
        HStack(spacing: 10) {
          Rectangle().fill(Color.green)
          Rectangle().fill(Color.yellow)
        }
      }
      .frame(maxWidth: .infinity, maxHeight: .infinity)
  ,#+end_src
#+end_src

#+begin_src org :exports src
  ,#+results:
#+end_src
[[file:images/swiftui-layout-previews-using-emacs-org-blocks/vstack.jpg]]

Place the cursor anywhere inside the source block (#+begin_src/#+end_src) and press C-c C-c (or M-x org-ctrl-c-ctrl-c).

To run interactively, change the /:swiftui/ param to /interactive/ and press C-c C-c (or M-x org-ctrl-c-ctrl-c). When running interactively, press "q" (without ⌘) to quit the Swift app.

comments on [[https://twitter.com/xenodium/status/1194224168709083137][twitter]].

** Update

- Tweaked the snippet to make it more self-contained and made the steps more reproducible. Need to work out how to package things to make them more accessible. May be best to contribute as a patch to [[https://github.com/zweifisch/ob-swift][ob-swift]] and we can avoid the icky /advice-add/.
- Thanks to Chris Eidhof for PNG support (instead of TIFF). Also TIL Swift's /print/ has got a terminator param.

* [2020-05-22 Fri] Open Emacs elfeed links in the background
  :PROPERTIES:
  :CUSTOM_ID: open-emacs-elfeed-links-in-background
  :END:

#+ATTR_HTML: :width 75% :height 75%
[[file:images/open-emacs-elfeed-links-in-background/background-browse.gif]]

Christopher Wellons's [[https://github.com/skeeto/elfeed][elfeed]] is a wonderful Emacs rss reader. In Mike Zamansky's [[https://cestlaz.github.io/post/using-emacs-72-customizing-elfeed/][Using Emacs 72 - Customizing Elfeed]] video, he highlights a desire to open elfeed entries in the background. That is, open the current rss entry (or selected entries) without shifting focus from Emacs to your browser. This behaviour is somewhat analogous to ⌘-clicking/ctrl-clicking on multiple links in the browser without losing focus.

I've been wanting elfeed to open links in the background for some time. Zamansky's post was a great nudge to look into it. He points to the relevant [[https://github.com/skeeto/elfeed/blob/58ab1f8bcc3014206db42a7a26f3120ba5de4ca6/elfeed-search.el#L783][elfeed-search-browse-url]] function, re-implemented to suit his needs. In a similar spirit, I wrote a function to open the current rss entry (or selected entries) in the background.

I'm running macOS, so I took a look at [[https://github.com/emacs-mirror/emacs/blob/d714aa753b744c903d149a1f6c69262d958c313e/lisp/net/browse-url.el#L1018  I ][browse-url-default-macosx-browser]] to get an idea of how URLs are opened. Simple. It let's macOS handle it via the "open" command, invoked through /start process/. Looking at open's command-line options, we find /--background/ which "does not bring the application to the foreground."

#+begin_src emacs-lisp
  open --background http://xenodium.com
#+end_src

"b" is already bound to /elfeed-search-browse-url/, so in our snippet we'll bind "B" to our new background function, giving us some flexibility:

#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :bind (:map elfeed-search-mode-map
                ("B" . ar/elfeed-search-browse-background-url))
    :config
    (defun ar/elfeed-search-browse-background-url ()
      "Open current `elfeed' entry (or region entries) in browser without losing focus."
      (interactive)
      (let ((entries (elfeed-search-selected)))
        (mapc (lambda (entry)
                (assert (memq system-type '(darwin)) t "open command is macOS only")
                (start-process (concat "open " (elfeed-entry-link entry))
                               nil "open" "--background" (elfeed-entry-link entry))
                (elfeed-untag entry 'unread)
                (elfeed-search-update-entry entry))
              entries)
        (unless (or elfeed-search-remain-on-entry (use-region-p))
          (forward-line)))))
#+end_src

Maybe xdg-open does a similar thing on linux (I've not looked). Ping me if you have a linux solution and I can update the function.

Happy Emacsing.

ps. I noticed elfeed uses /browse-url-generic/ if /elfeed-search-browse-url/'s is invoked with a prefix. Setting  [[https://github.com/emacs-mirror/emacs/blob/d0e2a341dd9a9a365fd311748df024ecb25b70ec/lisp/net/browse-url.el#L534][browse-url-generic-program]] and [[https://github.com/emacs-mirror/emacs/blob/d0e2a341dd9a9a365fd311748df024ecb25b70ec/lisp/net/browse-url.el#L539][browse-url-generic-args]] to use background options may be a more generic solution. For now, a custom function does the job.

comments on [[https://twitter.com/xenodium/status/1263839324023525376][twitter]].

* [2020-05-11 Mon] Enrich Emacs dired's batching toolbox
  :PROPERTIES:
  :CUSTOM_ID: enrich-your-dired-batching-toolbox
  :END:

** Update
I now use [[https://github.com/xenodium/dwim-shell-command][dwim-shell-command]], which reduces the logic to:

  #+begin_src emacs-lisp :lexical no
    (defun dwim-shell-commands-image-to-jpg ()
      "Convert all marked images to jpg(s)."
      (interactive)
      (dwim-shell-command-on-marked-files
       "Convert to jpg"
       "convert -verbose '<<f>>' '<<fne>>.jpg'"
       :utils "convert"))
  #+end_src

** Original post
  Shell one-liners are super handy for batch-processing files. Say you'd like to convert a bunch of images from HEIC to jpg, you could use something like:

#+begin_src sh
  for f in *.HEIC ; do convert "$f" "${f%.*}.jpg"; done
#+end_src

Save the one-liner (or memorize it) and pull it from your toolbox next time you need it. This is handy as it is, but [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Emacs dired]] is just a file-management powerhouse. Its /dired-map-over-marks/ function is just a few elisp lines away from enabling all sorts of batch processing within your dired buffers.


Dired already enables selecting and deselecting files using all sorts of built-in mechanisms ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Marks-vs-Flags.html][dired-mark-files-regexp]], [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired-and-Find.html][find-name-dired]], etc) or wonderful third-party packages like Matus Goljer's [[https://github.com/Fuco1/dired-hacks][dired-filters]].

Regardless of how you selected your files, here's a snippet to run ImageMagick's [[https://imagemagick.org/script/convert.php][convert]] on a bunch of selected files:

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t; -*-

  (defun ar/dired-convert-image (&optional arg)
    "Convert image files to other formats."
    (interactive "P")
    (assert (or (executable-find "convert") (executable-find "magick.exe")) nil "Install imagemagick")
    (let* ((dst-fpath)
           (src-fpath)
           (src-ext)
           (last-ext)
           (dst-ext))
      (mapc
       (lambda (fpath)
         (setq src-fpath fpath)
         (setq src-ext (downcase (file-name-extension src-fpath)))
         (when (or (null dst-ext)
                   (not (string-equal dst-ext last-ext)))
           (setq dst-ext (completing-read "to format: "
                                          (seq-remove (lambda (format)
                                                        (string-equal format src-ext))
                                                      '("jpg" "png")))))
         (setq last-ext dst-ext)
         (setq dst-fpath (format "%s.%s" (file-name-sans-extension src-fpath) dst-ext))
         (message "convert %s to %s ..." (file-name-nondirectory dst-fpath) dst-ext)
         (set-process-sentinel
          (if (string-equal system-type "windows-nt")
              (start-process "convert"
                             (generate-new-buffer (format "*convert %s*" (file-name-nondirectory src-fpath)))
                             "magick.exe" "convert" src-fpath dst-fpath)
            (start-process "convert"
                           (generate-new-buffer (format "*convert %s*" (file-name-nondirectory src-fpath)))
                           "convert" src-fpath dst-fpath))
          (lambda (process state)
            (if (= (process-exit-status process) 0)
                (message "convert %s ✔" (file-name-nondirectory dst-fpath))
              (message "convert %s ❌" (file-name-nondirectory dst-fpath))
              (message (with-current-buffer (process-buffer process)
                         (buffer-string))))
            (kill-buffer (process-buffer process)))))
       (dired-map-over-marks (dired-get-filename) arg))))
#+end_src

The snippet can be shorter, but wouldn't be as friendly. We ask users to provide desired image format, spawn separate processes (avoids blocking Emacs), and generate a basic report. Also adds support for Windows.

[[file:images/enrich-your-dired-batching-toolbox/batch-dired.gif]]

** BEWARE

The snippet isn't currently capping the number of processes, but hey we can revise in the future...


** Update

Thanks to [[https://github.com/pbeliveau][Philippe Beliveau]] for pointing out a bug in snippet (now updated) and changes to make it Windows compatible.

* [2020-05-09 Sat] Banana oats pancakes recipe
  :PROPERTIES:
  :CUSTOM_ID: banana-oats-pancakes-recipe
  :END:
#+ATTR_HTML: :width 50% :height 50%
[[file:images/banana-oats-pancakes-recipe/banpan.jpg]]

** Blend


- Ripe banana.
- 2 Eggs.
- 1/3 cup instant oats.
- 1/2 teaspoon baking powder.

Really is this easy. Add all ingredients and blend.

** Cook


Medium to low heat. Cook for 3 minutes. Flip. Cook for 1 minute. You're done.

* [2020-05-06 Wed] Emacs: connect my Bluetooth speaker
  :PROPERTIES:
  :CUSTOM_ID: emacs-connect-my-bluetooth-speaker
  :END:
Connecting and disconnecting bluetooth devices on macOS is fairly simple: use the menu bar utility.

#+ATTR_HTML: :width 75% :height 75%
[[file:images/emacs-connect-my-bluetooth-speaker/macos-menu.png]]

/But could we make it quicker from our beloved editor?/

Turns out with a little elisp glue, we can fuzzy search our Bluetooth devices and toggle connections. We can use [[https://twitter.com/_abo_abo][Oleh Krehel's]] [[https://github.com/abo-abo/swiper][ivy-read]] for fuzzy searching and [[https://twitter.com/lap_felix][Felix Lapalme]]'s nifty [[https://github.com/lapfelix/BluetoothConnector][BluetoothConnector]] to list devices and toggle Bluetooth connections.

As a bonus, we can make it remember the last selected device, so you can quickly toggle it again.

#+begin_src emacs-lisp
  (defun ar/ivy-bluetooth-connect ()
    "Connect to paired bluetooth device."
    (interactive)
    (assert (string-equal system-type "darwin")
            nil "macOS only. Sorry :/")
    (assert (executable-find "BluetoothConnector")
            nil "Install BluetoothConnector from https://github.com/lapfelix/BluetoothConnector")
    (ivy-read "(Dis)connect: "
              (seq-map
               (lambda (item)
                 (let* ((device (split-string item " - "))
                        (mac (nth 0 device))
                        (name (nth 1 device)))
                   (propertize name
                               'mac mac)))
               (seq-filter
                (lambda (line)
                  ;; Keep lines like: af-8c-3b-b1-99-af - Device name
                  (string-match-p "^[0-9a-f]\\{2\\}" line))
                (with-current-buffer (get-buffer-create "*BluetoothConnector*")
                  (erase-buffer)
                  ;; BluetoothConnector exits with 64 if no param is given.
                  ;; Invoke with no params to get a list of devices.
                  (unless (eq 64 (call-process "BluetoothConnector" nil (current-buffer)))
                    (error (buffer-string)))
                  (split-string (buffer-string) "\n"))))
              :require-match t
              :preselect (when (boundp 'ar/misc-bluetooth-connect--history)
                           (nth 0 ar/misc-bluetooth-connect--history))
              :history 'ar/misc-bluetooth-connect--history
              :caller 'ar/toggle-bluetooth-connection
              :action (lambda (device)
                        (start-process "BluetoothConnector"
